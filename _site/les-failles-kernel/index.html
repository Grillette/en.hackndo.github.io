<!doctype html>
<html lang="fr-fr" class="no-js">

  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile" hreflang="fr">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
    <meta name="google-site-verification" content="JeRPv2CEcpONAy8C7dMr1nzjlpZxlxYCtt2PnuQ78g8" />
    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  
    <title>
      
        Les failles kernel - hackndo
      
    </title>

	<link rel="stylesheet" href="/assets/css/style.css?v=1.13"> <!-- Resource style -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Signika:600"> <!-- Logo font -->
    <script src="/assets/js/modernizr.js"></script> <!-- Modernizr -->
    
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/icones/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/icones/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/icones/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/icones/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/icones/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/icones/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/icones/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/icones/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icones/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icones/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icones/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/icones/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icones/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/res/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/icones/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  	
	<!-- RSS -->
    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="hackndo" />

    <!-- Twitter card -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@hackanddo" />
    <meta name="twitter:creator" content="@hackanddo" />
    <meta name="twitter:title" content="Les failles kernel" />
    <meta name="twitter:description" content="Quelles sont les failles relative au kernel ? Nous allons découvrir ça dans cet article" />
    
    <meta name="twitter:image" content="http://localhost:4000/assets/uploads/2016/07/kernel_2.jpg" />
    
  
    <!-- Google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
      ga('create', 'UA-80312745-1', 'auto');
      ga('send', 'pageview');
  
    </script>
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Les failles kernel" />
<meta name="author" content="Pixis" />
<meta property="og:locale" content="fr_FR" />
<meta name="description" content="Quelles sont les failles relative au kernel ? Nous allons découvrir ça dans cet article" />
<meta property="og:description" content="Quelles sont les failles relative au kernel ? Nous allons découvrir ça dans cet article" />
<link rel="canonical" href="http://localhost:4000/les-failles-kernel/" />
<meta property="og:url" content="http://localhost:4000/les-failles-kernel/" />
<meta property="og:site_name" content="hackndo" />
<meta property="og:image" content="http://localhost:4000/assets/uploads/2016/07/kernel_2.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-07-07T12:38:42+02:00" />
<script type="application/ld+json">
{"image":"http://localhost:4000/assets/uploads/2016/07/kernel_2.jpg","@type":"BlogPosting","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/icones/logo.png"},"name":"Pixis"},"url":"http://localhost:4000/les-failles-kernel/","headline":"Les failles kernel","dateModified":"2016-07-07T12:38:42+02:00","datePublished":"2016-07-07T12:38:42+02:00","author":{"@type":"Person","name":"Pixis"},"description":"Quelles sont les failles relative au kernel ? Nous allons découvrir ça dans cet article","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/les-failles-kernel/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

  <body>
    <header class="cd-main-header">
    <a href="/" class="cd-logo"><img src="/assets/icones/logo.png" /> <span class="cd-logo-title">hackndo</span></a>
		
    <a href="#0" class="cd-nav-trigger">Menu<span></span></a>

</header> <!-- .cd-main-header -->
    <main class="cd-main-content">
		<nav class="cd-side-nav">
            <div class="sidebar-about">
    <h1>
        <img id="site-logo" src="/assets/icones/logo.png" alt="logo" title="logo" />
        <a class="sidebar-title" href="/">
        hackndo
        </a>
    </h1>
    <p class="lead">Think out of the box</p>
</div>

<ul>
    <li class="cd-label">Blog</li>
    <li class="">
        <a href="/">Home</a>
    </li>
    
    
        
            
        
    
        
            
                <li class="">
                    <a href="/about/">À propos</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/archives/">Archives</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/contact/">Me contacter</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/disclaimer/">Disclaimer</a>
                </li>
            
        
    
        
    
        
            
        
    
        
            
                <li class="">
                    <a href="/projects/">Projets</a>
                </li>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
    
        
    
</ul>
<ul>
    <li class="cd-label">Liens</li>
    <li><a href="https://www.dailysecurity.fr/" target="_blank">Blog de Geluchat</a></li>
    <li><a href="http://lsdsecdaemon.com" target="_blank">Blog de Th3_l5D</a></li>
    <li><a href="http://inf0sec.fr" target="_blank">Blog de Matthieu</a></li>
</ul>
<p class="sidebar-copyright">&copy; 2019. Tous droits réservés.</p>
<div class="sidebar-social">
<ul>
  <li><a href="https://twitter.com/HackAndDo" title="Twitter" target="_blank"><img alt="Twitter" title="Twitter" src="/assets/icones/social/twitter.png" /></a></li>
  <li><a href="https://github.com/hackndo" title="Github" target="_blank"><img title="Github" alt="Github" src="/assets/icones/social/github.png" /></a></li>
  <li><a href="https://www.youtube.com/channel/UC9WYWHLdu9TK-0Hu3wcHJ9g" title="Youtube" target="_blank"><img title="Youtube" alt="Youtube" src="/assets/icones/social/youtube.png" /></a></li>
  <li><a href="https://discord.gg/9At6SUZ" title="Discord" target="_blank"><img title="Discord" alt="Discord" src="/assets/icones/social/discord.png" /></a></li>
  <li><a href="https://www.linkedin.com/in/romainbentz/" title="LinkedIn" target="_blank"><img title="LinkedIn" alt="LinkedIn" src="/assets/icones/social/linkedin.png" /></a></li>
  <li><a href="https://sh.hackndo.com" title="Shell" target="_blank"><img title="Shell" alt="Shell" src="/assets/icones/social/shell.png" /></a></li>
  <li><a href="/feed.xml" title="RSS" target="_blank"><img title="RSS" alt="RSS" src="/assets/icones/social/rss.png" /></a></li>
  <li><a href="https://ko-fi.com/hackndo" title="Ko-Fi" target="_blank"><img title="Ko-Fi" alt="Ko-Fi" src="/assets/icones/social/kofi.gif" /></a></li>
</ul>
</div>
        </nav>

        <div class="content-wrapper">
            <div class="post">
  
  <div class="post-cover">
    <img src="/assets/uploads/2016/07/kernel_2.jpg" alt="Les failles kernel" title="Les failles kernel" />
  </div>
  
  <h1 class="post-title">Les failles kernel</h1>
  <div class="post-info">
      <p class="alignleft">07 Jul 2016 <a class="post-comments-count" href="http://http://localhost:4000/les-failles-kernel/#disqus_thread"></a></p>
      <p class="alignright">Auteur : <strong><a href="https://twitter.com/HackAndDo">Pixis</a></strong></p>
      <div class="keywords">
        <span class="post-tags"><a href="/archives/#kernel-land"><i class="fas fa-tags"></i> Kernel Land</a><a href="/archives/#linux"><i class="fas fa-tags"></i> Linux</a></span>
      </div>
</div>

  <article>
  <p>Avec l’article d’introduction sur <a href="/le-monde-du-kernel/">le monde du kernel</a>, nous avons tous les éléments théoriques généraux qui permettent de comprendre pourquoi il est intéressant de trouver des failles dans le kernel.</p>

<p>Nous allons donc voir maintenant quelles sont ces failles. Non, nous n’allons pas encore mettre les mains dans le cambouis. Mais ce monde est tellement vaste qu’il est nécessaire d’avoir une vue globale avant de plonger la tête la première. Vous allez voir, ça reste quand même intéressant.</p>

<p>Par ailleurs, si vous avez des connaissances concernant les vulnérabilités existantes dans le User-Land, vous verrez qu’il y a beaucoup de ressemblances.</p>

<!--more-->

<h2 id="problèmes-de-pointeurs">Problèmes de pointeurs</h2>

<p>Un pointeur contient une adresse, et lorsqu’on veut récupérer ce qui se trouve à cette adresse, on déréférence le pointeur. Malheureusement (?) il existe de nombreux cas où les pointeurs ne pointent pas ou plus vers l’adresse voulue par le programmeur.</p>

<p>Par exemple, un pointeur statique est initialisé à <code class="highlighter-rouge">NULL</code> en C, <code class="highlighter-rouge">NULL</code> étant égal à <code class="highlighter-rouge">0x00</code>. Si jamais aucune autre valeur n’est associée au pointeur, et qu’il est déréférencé, alors ça créera un problème car le processus ou le kernel essaiera d’accéder à l’adresse mémoire <code class="highlighter-rouge">0x00</code> mais il y a rarement quelquechose de mappé à cette endroit. Rarement… Mais comme c’est dans le User-Land, nous pouvons mapper cette zone mémoire et y écrire ce que nous voulons.</p>

<p><a href="/assets/uploads/2016/07/dereferencement.png"><img src="/assets/uploads/2016/07/dereferencement.png" alt="dereferencement" /></a></p>

<p>De la même manière, si jamais la valeur d’un pointeur est écrasée, par exemple suite à un overflow, alors lors du déréférencement, au mieux si la zone mémoire est mappée, la valeur récupérée ne sera pas celle attendue et au pire il y aura un <em>panic</em>.</p>

<p>Il est donc très intéressant pour l’attaquant de voir comment tirer partie de ces problèmes de déréférencement avec les pointeurs <code class="highlighter-rouge">NULL</code> ou les pointeurs corrompus, dès lors qu’ils ne sont pas vérifiés avant d’être utilisés.</p>

<h2 id="corruption-mémoire">Corruption mémoire</h2>

<p>La mémoire peut être corrompue à deux niveaux. Dans la stack, associée à chaque thread quand il y a du code du kernel qui est exécuté (par exemple avec les syscalls), et dans la heap lorsque le code du kernel a besoin d’allouer de l’espace.</p>

<h3 id="kernel-stack">Kernel Stack</h3>

<p>Lorsqu’un processus est en cours d’exécution, il a deux stacks : une dans le user-land, et une dans le kernel-land.</p>

<p>Les deux fonctionnenent de manière relativement similaires, cependant la stack dans le kernel-land a quelques particularités : Sa taille est limitée, et toutes les stack kernel des processus partagent la même plage de mémoire, puisque la mémoire virtuelle du kernel est répliquée pour tous les processus. Ces stacks commencent et s’étendent à différents offset du Kernel-Land.</p>

<p>Magré ces différences, les vulnérabilités que nous connaissons pour la stack dans le user-land s’appliquent très bien pour le kernel-land (buffer overflows et variantes).</p>

<h3 id="kernel-heap">Kernel Heap</h3>

<p>Le kernel a besoin de mémoire pour stocker différents objets. Par exemple, si un processus ouvre un fichier, le kernel devra enregistrer quelque part les informations nécessaires pour garder la trace de cette ouverture de fichier. Pour cela, un alloueur de mémoire interne au kernel, optimisé pour lui, communique avec l’alloueur de mémoire situé au niveau matériel, et demande des pages mémoires qu’il divise en morceaux, <em>chunks</em>, pour stocker les objets.</p>

<p>Si une page est remplie, une nouvelle page est demandée, et les infos de chaque page sont enregistrées, parfois au début ou à la fin de la page.</p>

<p><a href="/assets/uploads/2016/07/heap_allocation.png"><img src="/assets/uploads/2016/07/heap_allocation.png" alt="heap_allocation" /></a></p>

<p>Par ailleurs, sans rentrer dans les détails, on peut parfois prédire assez précisément l’ordre des chunks qui seront utilisés, donc on peut organiser l’ordre des objets que l’on utilise dans une page. C’est un vecteur d’attaque car avec des techniques d’overflow il est possible d’écrire sur des objets que l’on choisi, ou encore d’écrire sur les infos de la page mémoire utilisée.</p>

<h2 id="problèmes-dentiers">Problèmes d’entiers</h2>

<p>Différents problèmes existent avec les entiers. Les plus communs sont les overflows d’entiers et les problèmes de conversion de signes.</p>

<p>Les overflow d’entiers, c’est lorsqu’on essaie de faire rentrer un entier trop grand dans une variable. Si l’entier n’est pas signé (donc seulement des valeurs positives) alors le comportement est souvent de supprimer les bits qui “dépassent”, et si l’entier est signé, il y a dans la plupart des cas une inversion de signe.</p>

<p>Prenons cet exemple pour une architecture 32bits.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* count est un entier */</span>

<span class="kt">size_t</span> <span class="n">ssize</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>                       <span class="c1">// [1]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ssize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">myStructure_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">count</span><span class="p">;</span>  <span class="c1">// [2]</span>

<span class="n">myList</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">ssize</span><span class="p">,</span> <span class="n">__GFP_WAIT</span><span class="p">);</span>             <span class="c1">// [3]</span>
</code></pre></div></div>

<p>Dans cet exemple, count va être multiplié par la taille de la structure <code class="highlighter-rouge">myStructure_t</code> qu’on considère de <strong>4 octets</strong>. Si jamais <code class="highlighter-rouge">count</code> vaut plus que <code class="highlighter-rouge">0x3FFFFFFF</code>, la vérification en <strong>[1]</strong> est toujours sautée parce que <code class="highlighter-rouge">count</code> est spérieur à zéro, mais suite à la multiplication <strong>[2]</strong>, <code class="highlighter-rouge">ssize</code> va avoir une valeur trop grande pour rentrer dans un <code class="highlighter-rouge">size_t</code> qui ici est une valeur pouvant contenir 32 bits. En effet <code class="highlighter-rouge">0x40000000 * 4 = 0x100000000</code>, valeur de 35 bits. Le résultat est que le bit de poids fort en trop est supprimé, donc la valeur de <code class="highlighter-rouge">ssize</code> sera <code class="highlighter-rouge">0</code>. Ainsi, <code class="highlighter-rouge">myList</code> aura une taille plus petite que prévue suite à <strong>[3]</strong>. Il suffit alors que plus loin dans le code, on essaie d’accéder ou d’écrire à un emplacement mémoire attendu de <code class="highlighter-rouge">myList</code> pour créer un overflow.</p>

<p>On rencontre également des soucis avec les entiers lors de conversion de signes. Lorsqu’un entier est considéré comme signé à un endroit, et non signé à un autre, il peut alors prendre deux valeurs totalement différentes, ce qui est rarement voulu par le programmeur, et exploitable par … nous !</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">signed</span> <span class="kt">int</span> <span class="n">myLen</span><span class="p">;</span>
<span class="c1">// [...]</span>
<span class="cm">/* Nous contrôlons myLen */</span>
<span class="c1">// [...]</span>
<span class="k">if</span> <span class="p">(</span><span class="n">myLen</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>                 <span class="c1">// [1]</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">myLen</span><span class="p">)</span>    <span class="c1">// [2]</span>
</code></pre></div></div>

<p>Comme nous contrôlons <code class="highlighter-rouge">myLen</code> nous pouvons lui donner une valeur négative qui passera la vérification <strong>[1]</strong>. Cependant, le prototype de <code class="highlighter-rouge">memcpy</code> est</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="nf">memcpy</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span> <span class="p">);</span>
</code></pre></div></div>

<p>donc on voit que <code class="highlighter-rouge">count</code> est de type <code class="highlighter-rouge">size_t</code> qui est en fait un entier non signé. Ainsi, notre <code class="highlighter-rouge">myLen</code> va être converti en un entier non signé qui peut potentiellement avoir une taille bien supérieure à <code class="highlighter-rouge">10</code> et ainsi provoquer un overflow en <strong>[2]</strong>.</p>

<h2 id="race-conditions">Race conditions</h2>

<p>Une race condition peut arriver lorsque au moins deux acteurs entrent en concurrence, et que le résultat des opérations diffère selon l’acteur qui a agit avant l’autre. Ça se produit lorsque les deux acteurs travaillent en même temps, quand plusieurs CPU tournent par exemple, ou lorsqu’ils s’entrecroisent s’il n’y a qu’un CPU et que ce CPU alterne entre les deux tâches pour qu’elles s’exécutent avec un pseudo-parallèlisme.</p>

<p>Ainsi, si nous nous intercalons entre des instructions du kernel, nous pouvons trouver des vecteurs d’exploitation.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span> 

<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span>
<span class="c1">// [...]</span>
<span class="n">buff</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="n">__GFP_WAIT</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2048</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//  ----------------------   [1]</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">vfs_read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dans cet exemple, un buffer <code class="highlighter-rouge">buff</code> de 2048 octets est préparé pour recevoir le contenu d’un fichier. On vérifie que la taille du fichier est inférieure à 2048 octets, et si c’est le cas, on copie sont contenu dans <code class="highlighter-rouge">buff</code>. Mais si modifions le contenu du fichier entre la vérification et la copie en <strong>[1]</strong>, il est alors possible de créer un fichier plus grand que 2048 octets et ainsi provoquer un buffer overflow.</p>

<h2 id="autres-bugs">Autres bugs</h2>

<p>Il existe encore plein d’autres bugs exploitables. Un dernier exemple, les compteurs de références. En effet, il y a plein de choses qui sont partagées entre les processus. Le kernel ne va allouer de la mémoire pour un objet qu’une seule fois, et il partagera cette mémoire aux processus qui en ont besoin. Il garde en mémoire le nombre de processus qui l’utilisent, et lorsque ce nombre tombe à zéro, alors l’objet peut être libéré.</p>

<p>Mais il arrive parfois que des morceaux de codes oublient de notifier le kernel qu’il n’ont plus besoin de l’objet. Dans ce cas, l’appel à ce morceau de code (qui alloue sans libérer) en boucle va faire augmenter le compteur de références du kernel, jusqu’à un <em>integer overflow</em>, qui peut ensuite être potentiellement exploité.</p>

<hr />

<p>Voilà, nous avons fait un passage sur les grands bugs rencontrés qui peuvent conduire à des exploitations du kernel. Mais alors, comment les exploiter ? Pour cela, nous avons besoin de quelques rappels nécessaires sur <a href="/rappels-d-architecture">l’architecture d’un ordinateur</a></p>

  </article>
</div>
<div class="keywords">
    <span class="post-tags"><a href="/archives/#kernel-land"><i class="fas fa-tags"></i> Kernel Land</a><a href="/archives/#linux"><i class="fas fa-tags"></i> Linux</a></span>
  </div>


<br />
<div class="box">
  <div class="dash">
    <div class="picture">
      <img src="/assets/icones/pixis_logo.png" alt="logo" title="logo" />
    </div>
    <div class="box_content">
      <strong>Auteur</strong> : <a href="/contact/" target="_blank">Pixis</a><br />
      Créateur du blog, suivez-moi sur <a href="https://twitter.com/HackAndDo/" target="_blank">twitter</a> ou <a href="https://discord.gg/9At6SUZ" target="blank">discord</a>
    </div>
    
  </div>
</div>


<div class="related">
  <h2>Articles similaires</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/pass-the-hash/">
            Pass the Hash
            <small>18 Dec 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/remote-lsass-dump-passwords/">
            Extraction des secrets de lsass à distance
            <small>28 Nov 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/bloodhound/">
            BloodHound
            <small>30 Jul 2019</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    
    var disqus_config = function () {
        this.page.url = 'http://localhost:4000/les-failles-kernel/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '0000-0000-0000-0014';
    };
    
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//hackndo.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

        </div>
    </main>
    <script src="/assets/js/jquery-2.1.4.js"></script>
    <script src="/assets/js/jquery.menu-aim.js"></script>
    <script src="/assets/js/anchor.min.js"></script>
    <script src="/assets/js/main.js"></script> <!-- Resource jQuery -->
  </body>
</html>