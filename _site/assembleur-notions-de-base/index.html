<!doctype html>
<html lang="fr-fr" class="no-js">

  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile" hreflang="fr">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
    <meta name="google-site-verification" content="JeRPv2CEcpONAy8C7dMr1nzjlpZxlxYCtt2PnuQ78g8" />
    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  
    <title>
      
        Assembleur - Notions de base - hackndo
      
    </title>

	<link rel="stylesheet" href="/assets/css/style.css?v=1.13"> <!-- Resource style -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Signika:600"> <!-- Logo font -->
    <script src="/assets/js/modernizr.js"></script> <!-- Modernizr -->
    
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/icones/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/icones/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/icones/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/icones/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/icones/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/icones/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/icones/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/icones/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icones/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icones/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icones/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/icones/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icones/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/res/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/icones/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  	
	<!-- RSS -->
    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="hackndo" />

    <!-- Twitter card -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@hackanddo" />
    <meta name="twitter:creator" content="@hackanddo" />
    <meta name="twitter:title" content="Assembleur - Notions de base" />
    <meta name="twitter:description" content="L'assembleur est obscur pour vous ? Voici un article qui vous permettra d'y voir plus clair." />
    
    <meta name="twitter:image" content="http://localhost:4000/assets/uploads/2015/04/BACKGROUND.jpg" />
    
  
    <!-- Google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
      ga('create', 'UA-80312745-1', 'auto');
      ga('send', 'pageview');
  
    </script>
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Assembleur - Notions de base" />
<meta name="author" content="Pixis" />
<meta property="og:locale" content="fr_FR" />
<meta name="description" content="L’assembleur est obscur pour vous ? Voici un article qui vous permettra d’y voir plus clair." />
<meta property="og:description" content="L’assembleur est obscur pour vous ? Voici un article qui vous permettra d’y voir plus clair." />
<link rel="canonical" href="http://localhost:4000/assembleur-notions-de-base/" />
<meta property="og:url" content="http://localhost:4000/assembleur-notions-de-base/" />
<meta property="og:site_name" content="hackndo" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-04-22T00:00:00+02:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/icones/logo.png"},"name":"Pixis"},"url":"http://localhost:4000/assembleur-notions-de-base/","headline":"Assembleur - Notions de base","dateModified":"2015-04-22T00:00:00+02:00","datePublished":"2015-04-22T00:00:00+02:00","author":{"@type":"Person","name":"Pixis"},"description":"L’assembleur est obscur pour vous ? Voici un article qui vous permettra d’y voir plus clair.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/assembleur-notions-de-base/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

  <body>
    <header class="cd-main-header">
    <a href="/" class="cd-logo"><img src="/assets/icones/logo.png" /> <span class="cd-logo-title">hackndo</span></a>
		
    <a href="#0" class="cd-nav-trigger">Menu<span></span></a>

</header> <!-- .cd-main-header -->
    <main class="cd-main-content">
		<nav class="cd-side-nav">
            <div class="sidebar-about">
    <h1>
        <img id="site-logo" src="/assets/icones/logo.png" alt="logo" title="logo" />
        <a class="sidebar-title" href="/">
        hackndo
        </a>
    </h1>
    <p class="lead">Think out of the box</p>
</div>

<ul>
    <li class="cd-label">Blog</li>
    <li class="">
        <a href="/">Home</a>
    </li>
    
    
        
            
        
    
        
            
                <li class="">
                    <a href="/about/">À propos</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/archives/">Archives</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/contact/">Me contacter</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/disclaimer/">Disclaimer</a>
                </li>
            
        
    
        
    
        
            
        
    
        
            
                <li class="">
                    <a href="/projects/">Projets</a>
                </li>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
    
        
    
</ul>
<ul>
    <li class="cd-label">Liens</li>
    <li><a href="https://www.dailysecurity.fr/" target="_blank">Blog de Geluchat</a></li>
    <li><a href="http://lsdsecdaemon.com" target="_blank">Blog de Th3_l5D</a></li>
    <li><a href="http://inf0sec.fr" target="_blank">Blog de Matthieu</a></li>
</ul>
<p class="sidebar-copyright">&copy; 2019. Tous droits réservés.</p>
<div class="sidebar-social">
<ul>
  <li><a href="https://twitter.com/HackAndDo" title="Twitter" target="_blank"><img alt="Twitter" title="Twitter" src="/assets/icones/social/twitter.png" /></a></li>
  <li><a href="https://github.com/hackndo" title="Github" target="_blank"><img title="Github" alt="Github" src="/assets/icones/social/github.png" /></a></li>
  <li><a href="https://www.youtube.com/channel/UC9WYWHLdu9TK-0Hu3wcHJ9g" title="Youtube" target="_blank"><img title="Youtube" alt="Youtube" src="/assets/icones/social/youtube.png" /></a></li>
  <li><a href="https://discord.gg/9At6SUZ" title="Discord" target="_blank"><img title="Discord" alt="Discord" src="/assets/icones/social/discord.png" /></a></li>
  <li><a href="https://www.linkedin.com/in/romainbentz/" title="LinkedIn" target="_blank"><img title="LinkedIn" alt="LinkedIn" src="/assets/icones/social/linkedin.png" /></a></li>
  <li><a href="https://sh.hackndo.com" title="Shell" target="_blank"><img title="Shell" alt="Shell" src="/assets/icones/social/shell.png" /></a></li>
  <li><a href="/feed.xml" title="RSS" target="_blank"><img title="RSS" alt="RSS" src="/assets/icones/social/rss.png" /></a></li>
  <li><a href="https://ko-fi.com/hackndo" title="Ko-Fi" target="_blank"><img title="Ko-Fi" alt="Ko-Fi" src="/assets/icones/social/kofi.gif" /></a></li>
</ul>
</div>
        </nav>

        <div class="content-wrapper">
            <div class="post">
  
  <div class="post-cover">
    <img src="/assets/uploads/2015/04/BACKGROUND.jpg" alt="Assembleur - Notions de base" title="Assembleur - Notions de base" />
  </div>
  
  <h1 class="post-title">Assembleur - Notions de base</h1>
  <div class="post-info">
      <p class="alignleft">22 Apr 2015 <a class="post-comments-count" href="http://http://localhost:4000/assembleur-notions-de-base/#disqus_thread"></a></p>
      <p class="alignright">Auteur : <strong><a href="https://twitter.com/HackAndDo">Pixis</a></strong></p>
      <div class="keywords">
        <span class="post-tags"><a href="/archives/#linux"><i class="fas fa-tags"></i> Linux</a></span>
      </div>
</div>

  <article>
  <p>Salut tout le monde, voici un nouvel article qui va permettre, je pense, d’éclaircir bon nombre de notions que j’ai déjà abordées dans mes articles précédents, et qui permettront également de faciliter la compréhension des articles à venir.</p>

<p>Cet article a un but modeste : Comprendre la sortie d’un <code class="highlighter-rouge">disass main</code> sur un programme relativement simple (Mais si ! vous savez, cette commande dans gdb qui permet de désassembler - i.e. produire le code assembleur - un binaire)</p>

<!--more-->

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>disassembly-flavor intel
<span class="o">(</span>gdb<span class="o">)</span> disass main
Dump of assembler code <span class="k">for function </span>main:
   0x080483f2 &lt;+0&gt;:     push   ebp
   0x080483f3 &lt;+1&gt;:     mov    ebp,esp
   0x080483f5 &lt;+3&gt;:     sub    esp,0x18
   0x080483f8 &lt;+6&gt;:     mov    DWORD PTR <span class="o">[</span>esp+0x4],0x2
   0x08048400 &lt;+14&gt;:    mov    DWORD PTR <span class="o">[</span>esp],0x28
   0x08048407 &lt;+21&gt;:    call   0x80483dc &lt;add&gt;
   0x0804840c &lt;+26&gt;:    mov    DWORD PTR <span class="o">[</span>ebp-0x4],eax
   0x0804840f &lt;+29&gt;:    mov    eax,DWORD PTR <span class="o">[</span>ebp-0x4]
   0x08048412 &lt;+32&gt;:    leave  
   0x08048413 &lt;+33&gt;:    ret    
End of assembler dump.
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>disassembly-flavor att
<span class="o">(</span>gdb<span class="o">)</span> disass main
Dump of assembler code <span class="k">for function </span>main:
   0x080483f2 &lt;+0&gt;:     push   %ebp
   0x080483f3 &lt;+1&gt;:     mov    %esp,%ebp
   0x080483f5 &lt;+3&gt;:     sub    <span class="nv">$0x18</span>,%esp
   0x080483f8 &lt;+6&gt;:     movl   <span class="nv">$0x2</span>,0x4<span class="o">(</span>%esp<span class="o">)</span>
   0x08048400 &lt;+14&gt;:    movl   <span class="nv">$0x28</span>,<span class="o">(</span>%esp<span class="o">)</span>
   0x08048407 &lt;+21&gt;:    call   0x80483dc &lt;add&gt;
   0x0804840c &lt;+26&gt;:    mov    %eax,-0x4<span class="o">(</span>%ebp<span class="o">)</span>
   0x0804840f &lt;+29&gt;:    mov    <span class="nt">-0x4</span><span class="o">(</span>%ebp<span class="o">)</span>,%eax
   0x08048412 &lt;+32&gt;:    leave  
   0x08048413 &lt;+33&gt;:    ret    
End of assembler dump.
</code></pre></div></div>

<p>Mais diantres, que veut dire ce charabia ? Et puis pourquoi la même commande a produit deux résultats différents ? C’est ce que nous allons voir maintenant, ce code n’aura plus de secrets pour vous…;</p>

<h2 id="syntaxe">Syntaxe</h2>

<p>Dans un premier temps, nous allons expliquer pourquoi la même commande a produit deux résultats (pas vraiment) différents. C’est tout simplement une question de syntaxe. Il existe deux principales syntaxes pour représenter du langage assembleur x86 : La syntaxe Intel (plutôt retrouvée dans les environnements Windows) et la syntaxe AT&amp;T (retrouvée dans les environnements Unix). Les différences entre ces deux syntaxes sont minimes. Avant de les lister, voyons la structure commune de ces deux syntaxes :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OPERATION [ARG1 [, ARG2]]
</code></pre></div></div>

<p>L’opération est le nom de l’opération à effectuer. Les opérations prennent 0, 1 ou 2 arguments.</p>

<p>Pour supprimer toutes ambiguïtés entre les deux syntaxes, voici les différences :</p>

<h3 id="ordre-des-paramètres">Ordre des paramètres</h3>

<p>Lorsqu’une opération prend deux paramètres et que l’opération n’est pas commutative (i.e. <strong>a OP b</strong> et <strong>b OP a</strong> ne donnent pas le même résultat), il est important de connaître l’ordre de ces paramètres. Si nous voulions par exemple copier le nombre 42 dans le registre <code class="highlighter-rouge">EAX</code>, voici les deux syntaxes que nous retrouverions :</p>

<h4 id="intel-">Intel :</h4>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">OPERATION</span> <span class="n">DESTINATION</span><span class="p">,</span> <span class="n">SOURCE</span>
</code></pre></div></div>

<p>Exemple :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">42</span>
</code></pre></div></div>

<h4 id="att-">AT&amp;T :</h4>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">OPERATION</span> <span class="n">SOURCE</span><span class="p">,</span> <span class="n">DESTINATION</span>
</code></pre></div></div>

<p>Exemple :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov $42, %eax
</code></pre></div></div>

<h3 id="taille-des-paramètres">Taille des paramètres</h3>

<h4 id="intel--1">Intel :</h4>

<p>Comme la taille des paramètres ne doit être indiquée que pour les paramètres non immédiats (non constant, donc avec une taille inconnue) c’est à dire les registres, elle est tout simplement intégrée au nom du registre :</p>

<p><code class="highlighter-rouge">RAX</code>, <code class="highlighter-rouge">EAX</code>, <code class="highlighter-rouge">AX</code>, <code class="highlighter-rouge">AL</code> impliquent respectivement qword (64 bits), long (double word, 32 bits), word (16 bits) et byte (octet 8 bits).</p>

<h4 id="att--1">AT&amp;T :</h4>

<p>Les noms des opérations sont suffixés avec une lettre correspondant à la taille des paramètres manipulés.</p>

<p><code class="highlighter-rouge">q</code>, <code class="highlighter-rouge">l</code>, <code class="highlighter-rouge">w</code> et <code class="highlighter-rouge">b</code> (comme vus pour la syntaxe Intel)</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>movl $42, %eax
</code></pre></div></div>

<p>42 sera copié dans <code class="highlighter-rouge">EAX</code>, sur une taille de 32 bits (l’espace non occupé sera mis à zéro)</p>

<h3 id="préfixe-de-variable">Préfixe de variable</h3>

<h4 id="intel--2">Intel :</h4>

<p>Les variables ne sont pas préfixées comme nous avons pu le voir :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">42</span>
</code></pre></div></div>

<h4 id="att--2">AT&amp;T :</h4>

<p>En revanche, en ce qui concerne la syntaxe AT&amp;T, nous trouvons un <code class="highlighter-rouge">$</code> devant les valeurs immédiates (i.e. les constantes) et un <code class="highlighter-rouge">%</code> devant les registres, comme dans cet exemple :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>movl $42, %eax
</code></pre></div></div>

<h3 id="adresse-effective">Adresse effective</h3>

<p>Lorsqu’on parle de variables en mémoire, l’adresse effective représente l’adresse de la case mémoire où est stockée la variable. En assembleur x86, nous avons différents éléments pour définir une adresse mémoire</p>

<ul>
  <li><strong>base</strong> : Registre de 32 bits (contenant le plus souvent une adresse)</li>
  <li><strong>index</strong> <em>(Optionnel)</em> : Registre de 32 bits (contenant le plus souvent une adresse)</li>
  <li><strong>scale</strong> <em>(Optionnel)</em> : Facteur valant 1, 2, 4 ou 8 multipliant <strong>index</strong></li>
  <li><strong>disp</strong> <em>(Optionnel)</em> : Déplacement (<em>displacement</em>), ajouté ou déduit à la fin du calcul</li>
  <li><strong>segreg</strong> <em>(Optionnel)</em> : Segment mémoire (<em>Segment Register</em>) indiquant le segment dans lequel se trouve la donnée</li>
</ul>

<h4 id="intel--3">Intel :</h4>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>segreg:[base+index*scale+disp]
</code></pre></div></div>

<p>Le calcul est effectué, puis les crochets indiquent que le résultat est une adresse mémoire (l’adresse effective), comme dans cet exemple :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov eax, [ ebx + ecx*2 + 0x80848c48 ]
</code></pre></div></div>

<p>Dans cet exemple, le double du contenu de <code class="highlighter-rouge">ECX</code> est ajouté au contenu de <code class="highlighter-rouge">EBX</code>, auquel on ajoute l’offset indiquée (ici <code class="highlighter-rouge">0x8084c48</code>), ce qui nous donne une nouvelle adresse. La valeur contenue à cette adresse est assignée à <code class="highlighter-rouge">EAX</code>.</p>

<p>Prenons un cas plus simple, pour être certains de ne pas nous emmêler les pinceaux. Soient :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ebx</span> <span class="o">=</span> <span class="mh">0x80000000</span>
<span class="n">ecx</span> <span class="o">=</span> <span class="mh">0x00000002</span>
</code></pre></div></div>

<p>Si on trouve l’instruction</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov eax, [ ebx + ecx*2 + 0x0000000a]
</code></pre></div></div>

<p>Alors le contenu des crochet se décompose de la manière suivante</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ebx</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="mh">0x80000004</span>
</code></pre></div></div>

<p>Puis on ajoute l’offset</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mh">0x80000004</span> <span class="o">+</span> <span class="mh">0x0000000a</span> <span class="o">=</span> <span class="mh">0x8000000e</span>
</code></pre></div></div>

<p>Ensuite, on cherche ce qu’il y a en mémoire à l’adresse <code class="highlighter-rouge">0x8000000e</code>, et ce qu’on y trouve, on le met dans <code class="highlighter-rouge">EAX</code>.</p>

<h4 id="att--3">AT&amp;T :</h4>

<p>La syntaxe est particulière et assez peu intuitive comparée à celle d’Intel. Sa forme générique est</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">%segreg</span><span class="o">:</span><span class="n">disp</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">scale</span><span class="p">)</span>
</code></pre></div></div>

<p>Comme dans l’exemple suivant :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>movl 0x80848c48(%ebx,%ecx,4), %eax
</code></pre></div></div>

<p>Exemple qui a le même comportement que celui donné pour Intel.</p>

<p>Voilà la fin d’un rapide résumé des différences entre les deux syntaxes les plus retrouvées. Dans l’ensemble de mes articles, <strong>j’utilise la syntaxe Intel</strong>, qui, bien qu’elle soit connotée Windows, me semble beaucoup plus claire donc adaptée à ces articles.</p>

<p>Nous allons voir maintenant les instructions les plus rencontrées lorsque l’on désassemble un programme. Cette liste est loin d’être exhaustive, mais elle permettra de s’y retrouver dans la majorité des exemples que j’ai donnés ou que je fournirai plus tard.</p>

<h2 id="instructions-communes">Instructions communes</h2>

<h3 id="opérations-mathématiques">Opérations mathématiques</h3>

<h4 id="sub">SUB</h4>

<p>Permet de soustraire une valeur à une autre</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sub</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">42</span>
</code></pre></div></div>

<p>eax = eax - 42</p>

<h4 id="add">ADD</h4>

<p>Permet d’additionner deux valeurs</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">add</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">42</span>
</code></pre></div></div>

<p>eax = eax + 42</p>

<h3 id="opérations-logiques">Opérations logiques</h3>

<h4 id="and">AND</h4>

<p>Effectue un ET logique</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">AND</span> <span class="mh">0x5</span><span class="p">,</span> <span class="mh">0x3</span>
</code></pre></div></div>

<p>5 est représenté en binaire par <code class="highlighter-rouge">101</code> et 3 par <code class="highlighter-rouge">011</code> donc un ET logique donne <code class="highlighter-rouge">001 = 0x1</code>. Ce code n’est pas utile, puisque le résultat n’est sauvé nulle part, on fera cette opération avec au moins un des deux paramètre qui est un registre.</p>

<h4 id="xor">XOR</h4>

<p>Effectue un XOR logique. Souvent utilisé pour initialiser une variable à 0 via <code class="highlighter-rouge">XOR var, var</code></p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">XOR</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
</code></pre></div></div>

<p>Ce code est très souvent retrouvé pour initialiser le registre eax à zéro, puisqu’un xor ne donne 1 que si les bits sont différents.</p>

<h3 id="assignations">Assignations</h3>

<h4 id="mov">MOV</h4>

<p>Assigne une valeur à une variable</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="mh">0x00000042</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">EAX</code> va contenir la valeur <code class="highlighter-rouge">0x00000042</code></p>

<h4 id="lea">LEA</h4>

<p>Assigne l’adresse d’une variable à une variable. <code class="highlighter-rouge">LEA</code> a une particularité, c’est que le deuxième argument est entre crochets, mais contrairement à d’habitude, cela ne veut pas dire qu’il sera déréférencé (c’est à dire que ça ne signifie pas que le résultat sera la variable située à l’adresse entre crochets).</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LEA eax, [ebp - 0xc]
</code></pre></div></div>

<p>Si <code class="highlighter-rouge">EBP</code> avait pour valeur <code class="highlighter-rouge">0xbffff484</code>, alors <code class="highlighter-rouge">ebp - 0xc</code> a pour valeur <code class="highlighter-rouge">0xbffff478</code>, et c’est bien cette adresse (et non la valeur contenue à cette adresse) qui sera stockée dans <code class="highlighter-rouge">EAX</code>.</p>

<h3 id="manipulation-de-la-pile">Manipulation de la pile</h3>

<h4 id="push">PUSH</h4>

<p>Pousse l’argument passé à <code class="highlighter-rouge">PUSH</code> au sommet de la pile</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">PUSH</span> <span class="n">ebp</span>
</code></pre></div></div>

<p>La valeur contenue dans <code class="highlighter-rouge">EBP</code> est mise sur le dessus de la pile</p>

<h4 id="pop">POP</h4>

<p>Retire l’élément au sommet de la pile, et l’assigne à la valeur passée en argument. (Si nous voulons être plus exacts, l’élément au sommet de la pile reste là où il est, et le registre <code class="highlighter-rouge">ESP</code> qui pointe sur le sommet de la pile est mis à jour en pointant vers la valeur précédente sur la pile)</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">POP</span> <span class="n">ebp</span>
</code></pre></div></div>

<p>L’élément qui était au sommet de la pile est assigné à <code class="highlighter-rouge">EBP</code>, et est retiré de la pile</p>

<h3 id="tests">Tests</h3>

<h4 id="cmp">CMP</h4>

<p>Compare les deux valeurs passées en argument</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CMP</span> <span class="n">ecx</span><span class="p">,</span> <span class="mh">0x10</span>
</code></pre></div></div>

<p>Pour comparer ces deux éléments, une soustraction signée <code class="highlighter-rouge">ecx - 0x10</code> est effectuée</p>

<h4 id="test-eax-eax">TEST EAX, EAX</h4>

<p>Cette opération est logiquement équivalente à</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">cmp</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">0</span>
</code></pre></div></div>

<p>Donc ce test permet de savoir si eax est positif ou non. Cependant, <code class="highlighter-rouge">CMP</code> effectue une soustraction, ce qui est plus lent que <code class="highlighter-rouge">TEST</code> qui effectue un <code class="highlighter-rouge">AND</code>. Mais le résultat est le même.</p>

<h4 id="jumps">Jumps</h4>

<p>Il existe de nombreuses instruction qui sautent à un autre endroit du code. Une instruction qui saute quelque soit la condition, et d’autres qui dépendent du résultat d’un test précédemment effectué. Sans condition, nous avons l’instruction</p>

<p><strong>JMP</strong></p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">JMP</span> <span class="mh">0x80844264</span>
</code></pre></div></div>

<p>qui va sauter à l’instruction située à l’adresse indiquée, quoiqu’il arrive.</p>

<p>Cependant, il existe de multiple sauts conditionnels. Nous n’allons pas tous les voir en détails ici, seulement ceux que nous retrouvons le plus. Ils seront présentés par paire, la condition et sa négation, représentée par un N (Not)</p>

<p><strong>JE - JNE</strong></p>

<p>Egal (Equal) - différent (Non Equal)</p>

<p><strong>JZ - JNZ</strong></p>

<p>Nul (Zero) - Non null (Non Zero)</p>

<p><strong>JA/JB - JNA/JNB (Non signé)</strong></p>

<p>Supérieur strictement (Above)/Inférieur strictement (Below) - Inférieur ou égal/Supérieur ou égal</p>

<p><strong>JAE/JBE - JNAE/JNBE</strong></p>

<p>Supérieur ou égal (Above or Equal)/Inférieur ou égal (Below or Equal) - Strictement inférieur/Strictement supérieur</p>

<p><strong>JG/JL (Signé)</strong></p>

<p>Supérieur (Greater)/ Inférieur (Lower)</p>

<h3 id="fonctions">Fonctions</h3>

<h4 id="call-adresse">CALL adresse</h4>

<p>L’instruction <code class="highlighter-rouge">call</code> permet de faire appel au code d’une autre fonction située à un espace mémoire différent. L’adresse qui lui est passée en argument permet de trouver ce code. Cet appel est en fait un condensé de deux instructions. La première permet de sauvegarder l’instruction qui suit le call (pour le retour de la fonction, afin de reprendre le fil d’exécution du programme) et la deuxième permet d’effectivement sauter à la fonction recherchée. Comme nous l’avons vu dans un article précédent sur le <a href="/fonctionnement-de-la-pile/">fonctionnement de la pile</a>, le registre qui contient l’instruction suivante est <code class="highlighter-rouge">EIP</code>. Un call est donc finalement la suite de ces deux instructions :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">PUSH</span> <span class="n">EIP</span>
<span class="k">JMP</span> <span class="n">adresse</span>
</code></pre></div></div>

<h4 id="leave">LEAVE</h4>

<p>A l’inverse <code class="highlighter-rouge">LEAVE</code> permet de préparer la sortie d’une fonction en récupérant les variables enregistrée lors du début de la fonction afin de retrouver le contexte d’exécution tel qu’il avait été enregistré juste avant d’exécuter le code de la fonction, tout détruisant ce qu’il restait du stackframe :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">MOV</span> <span class="n">ESP</span><span class="p">,</span> <span class="n">EBP</span>
<span class="k">POP</span> <span class="n">EBP</span>
</code></pre></div></div>

<h3 id="ret">RET</h3>

<p>Enfin, l’instruction <code class="highlighter-rouge">RET</code> permet de finaliser le travail de <code class="highlighter-rouge">LEAVE</code> en récupérant l’adresse de l’instruction à exécuter après le call, adresse qui avait été enregistrée sur la pile lors de l’instruction <code class="highlighter-rouge">CALL</code>, et de sauter à cette adresse</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">POP</span> <span class="n">EIP</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">EIP</code> a été modifiée et c’est l’instruction qui se situe à l’adresse contenue dans <code class="highlighter-rouge">EIP</code> qui sera ensuite traitée.</p>

<h3 id="misc">Misc</h3>

<p>Pour finir, une instruction qui peut paraître anodine comme ça, mais qui a sont importance certaine : L’instruction <code class="highlighter-rouge">NOP</code> (No OPeration). Cette instruction … ne fait rien. Si le processeur tombe sur cette instruction, il va tout simplement ne rien faire, et passer à l’instruction suivante.</p>

<p>Voilà, vous avez tous les éléments en main pour comprendre le programme désassemblé fourni au début de l’article. Y arriverez-vous ?</p>

<p>Comme je suis de bonne humeur et que je n’aime pas faire les choses à moitié, nous allons le faire ensemble ! Retroussez vos manches, c’est parti !</p>

<h2 id="mise-en-pratique">Mise en pratique</h2>

<p>Rappelons le code du début de l’article, et ne prenons que la version dans la syntaxe Intel.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> disass main
Dump of assembler code <span class="k">for function </span>main:
   0x080483f2 &lt;+0&gt;:     push   ebp
   0x080483f3 &lt;+1&gt;:     mov    ebp,esp
   0x080483f5 &lt;+3&gt;:     sub    esp,0x18
   0x080483f8 &lt;+6&gt;:     mov    DWORD PTR <span class="o">[</span>esp+0x4],0x2
   0x08048400 &lt;+14&gt;:    mov    DWORD PTR <span class="o">[</span>esp],0x28
   0x08048407 &lt;+21&gt;:    call   0x80483dc &lt;add&gt;
   0x0804840c &lt;+26&gt;:    mov    DWORD PTR <span class="o">[</span>ebp-0x4],eax
   0x0804840f &lt;+29&gt;:    mov    eax,DWORD PTR <span class="o">[</span>ebp-0x4]
   0x08048412 &lt;+32&gt;:    leave  
   0x08048413 &lt;+33&gt;:    ret    
End of assembler dump.
</code></pre></div></div>

<p>Pour que vous puissiez suivre, je ferai référence aux lignes telles qu’indiquées entre chevrons dans le code désassemblé. Par exemple, la ligne <code class="highlighter-rouge">+3</code> correspond à la ligne <code class="highlighter-rouge">0x080483f5 &lt;+3&gt;:     sub    esp,0x18</code> donc à l’instruction <code class="highlighter-rouge">sub esp, 0x18</code></p>

<p>Allons-y ! Nous avons donc le code assembleur de la fonction <code class="highlighter-rouge">main</code> d’un programme que nous ne connaissons pas. La fonction <code class="highlighter-rouge">main</code> est une fonction comme une autre du point de vue du processeur, il convient donc, comme n’importe quelle fonction, de commencer par les 3 premières lignes typiques d’un début de fonction (parfois un peu plus, mais le principe reste le même), qu’on appelle le <strong>prologue</strong>. Ces lignes permettent en sommes de sauvegarder l’état de la fonction précédente, et de préparer la pile pour les variables locales de la fonction courante.</p>

<p>La ligne <code class="highlighter-rouge">+0</code></p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">push</span>    <span class="n">ebp</span>
</code></pre></div></div>

<p>permet de pousser le registre <code class="highlighter-rouge">EBP</code> sur la pile. Pour rappel, <code class="highlighter-rouge">EBP</code> (Base Pointer) est le registre qui contient l’adresse du début du stackframe de la fonction courante. Comme nous entrons dans une fonction, il faut sauvegarder le début du stackframe de la fonction précédente, ce que fait cette ligne <code class="highlighter-rouge">+0</code>. Une fois ceci fait, il faut maintenant donner la valeur de notre nouvelle base de stackframe à <code class="highlighter-rouge">EBP</code>. Comme nous entrons à peine dans la fonction, nous n’avons encore rien empilé qui soit propre à la fonction, donc le sommet de la pile actuel correspond à la base du futur stackframe de la fonction main. Et où est contenue l’adresse du sommet de la pile ? Vous vous en souvenez, dans <code class="highlighter-rouge">ESP</code> (Stack Pointer ! Si ça vous est inconnu, je vous invite à relire l’article sur le <a href="/fonctionnement-de-la-pile/">fonctionnement de la pile</a>). La ligne <code class="highlighter-rouge">+1</code> enregistre alors le contenu de <code class="highlighter-rouge">ESP</code> dans <code class="highlighter-rouge">EBP</code></p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mov</span>    <span class="n">ebp</span><span class="p">,</span><span class="n">esp</span>
</code></pre></div></div>

<p>Voilà, notre registre <code class="highlighter-rouge">EBP</code> est prêt, il pointe sur le début du stackframe de la fonction <code class="highlighter-rouge">main</code>. Que fait la ligne suivante, ligne +3 ?</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sub</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x18</span>
</code></pre></div></div>

<p>Tout juste, elle soustrait <code class="highlighter-rouge">0x18</code> au registre <code class="highlighter-rouge">ESP</code>. <code class="highlighter-rouge">0x18</code> en hexadécimal, ça fait <code class="highlighter-rouge">1x16 + 8x1 = 24</code> en décimal. Rappelons que la pile grossit <strong>vers le bas</strong> pour les processeurs x86, cela veut dire que plus elle grossit, plus l’adresse du sommet de pile diminue. En soustrayant 24 de <code class="highlighter-rouge">ESP</code>, cela veut dire qu’on a fait grossir la pile de 24 octets. 24 octets sont alors alloués à la fonction <code class="highlighter-rouge">main</code> pour ses variables locales.</p>

<p>Voilà, nous avons le registre <code class="highlighter-rouge">EBP</code> qui pointe sur le début du stackframe, le registre <code class="highlighter-rouge">ESP</code> qui pointe sur le sommet de la pile, 24 octets plus loin.</p>

<p>Les deux lignes suivantes sont relativement similaires :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x080483f8 &lt;+6&gt;:     mov    DWORD PTR [esp+0x4],0x2
0x08048400 &lt;+14&gt;:    mov    DWORD PTR [esp],0x28
</code></pre></div></div>

<p>Ce sont deux instructions <code class="highlighter-rouge">MOV</code>, mais un peu plus compliquées que ce que nous avons vu jusque là. La première des deux lignes <code class="highlighter-rouge">+6</code> met la valeur <code class="highlighter-rouge">0x2</code> dans <code class="highlighter-rouge">DWORD PTR [esp+0x4]</code>. <code class="highlighter-rouge">DWORD</code> signifie que <code class="highlighter-rouge">0x2</code> va prendre la place d’un double word (32 bits). Or <code class="highlighter-rouge">0x2</code> pouvant être stockée sur un octet, les 3 autres seront initialisé à 0. <code class="highlighter-rouge">PTR [esp+0x4]</code> indique que <code class="highlighter-rouge">0x2</code> va être stocké à l’adresse <code class="highlighter-rouge">esp+0x4</code>. Rappelons encore que <code class="highlighter-rouge">ESP</code> contient l’adresse du sommet de la pile, donc <code class="highlighter-rouge">ESP + 0x4</code> contient l’adresse du deuxième emplacement de la pile (Une variable étant de la taille d’un <code class="highlighter-rouge">DWORD</code>, donc de 4 octets, sur une architecture 32 bits - parce que oui, 32 bits = 4 octets). La ligne <code class="highlighter-rouge">+6</code> met donc le nombre 2 en deuxième position sur la pile.</p>

<p>Avec ces explications, que fait la ligne <code class="highlighter-rouge">+14</code> ?</p>

<p>Elle met la valeur <code class="highlighter-rouge">0x28</code> (40 en décimal) à l’adresse contenue dans <code class="highlighter-rouge">ESP</code>, donc <code class="highlighter-rouge">0x28</code> est placé au sommet de la pile. Voici où nous en sommes :</p>

<p><a href="/assets/uploads/2015/04/img_55382697a63ab.png"><img src="/assets/uploads/2015/04/img_55382697a63ab.png" alt="img_55382697a63ab" /></a></p>

<p>Mais pourquoi donc placer ces valeurs arbitrairement comme ça ? Pourquoi sur la pile ? Quelle utilité ? Regardons la ligne suivante :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">call</span>    <span class="mh">0x80483dc</span> <span class="o">&lt;</span><span class="k">add</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>Une instruction <code class="highlighter-rouge">CALL</code> ! Elle fait appel à la fonction située à l’adresse <code class="highlighter-rouge">0x80483dc</code>, et gdb nous a même retrouvé le nom de cette fonction, qui s’appelle <code class="highlighter-rouge">add()</code>. Fort bien, nous allons pouvoir désassembler <code class="highlighter-rouge">add</code> pour voir de quoi il en retourne !</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> disass add
Dump of assembler code <span class="k">for function </span>add:
   0x080483dc &lt;+0&gt;:     push   ebp
   0x080483dd &lt;+1&gt;:     mov    ebp,esp
   0x080483df &lt;+3&gt;:     sub    esp,0x10
   0x080483e2 &lt;+6&gt;:     mov    eax,DWORD PTR <span class="o">[</span>ebp+0xc]
   0x080483e5 &lt;+9&gt;:     mov    edx,DWORD PTR <span class="o">[</span>ebp+0x8]
   0x080483e8 &lt;+12&gt;:    add    eax,edx
   0x080483ea &lt;+14&gt;:    mov    DWORD PTR <span class="o">[</span>ebp-0x4],eax
   0x080483ed &lt;+17&gt;:    mov    eax,DWORD PTR <span class="o">[</span>ebp-0x4]
   0x080483f0 &lt;+20&gt;:    leave  
   0x080483f1 &lt;+21&gt;:    ret    
End of assembler dump.


</code></pre></div></div>

<p>Nous retrouvons le même schéma sur les trois premières lignes que celui de la fonction <code class="highlighter-rouge">main()</code>, le prologue de la fonction qui sauvegarde <code class="highlighter-rouge">EBP</code> de la fonction précédente (la fonction <code class="highlighter-rouge">main</code>), puis assigne <code class="highlighter-rouge">ESP</code> à <code class="highlighter-rouge">EBP</code> pour initialiser le début de la stackframe, et enfin qui décale le sommet de la pile de 16 octets pour que la fonction <code class="highlighter-rouge">add</code> puisse travailler avec ses variables locales.</p>

<p>Ensuite les lignes <code class="highlighter-rouge">+6</code> et <code class="highlighter-rouge">+9</code> sont similaires</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x080483e2 &lt;+6&gt;:     mov    eax,DWORD PTR [ebp+0xc]
0x080483e5 &lt;+9&gt;:     mov    edx,DWORD PTR [ebp+0x8]
</code></pre></div></div>

<p>Ce sont deux instructions <code class="highlighter-rouge">MOV</code> qui initialisent <code class="highlighter-rouge">eax</code> et <code class="highlighter-rouge">edx</code>. Si on regarde l’instruction à la ligne <code class="highlighter-rouge">+12</code>, <code class="highlighter-rouge">add    eax,edx</code>, on remarque que ces deux registres vont être additionnés.</p>

<p>Par ailleurs, le nom de la fonction étant <code class="highlighter-rouge">add</code>, il y a fort à parier que le but de cette fonction est d’additionner deux nombres. Bref, revenons-en à nos deux lignes : Nous avons déjà vu la syntaxe <code class="highlighter-rouge">DWORD PTR [ebp + 0xc]</code> dans la fonction <code class="highlighter-rouge">main</code>. Cela signifie que nous allons chercher à l’adresse <code class="highlighter-rouge">EBP + 0xc</code>, et nous allons prendre le <code class="highlighter-rouge">DWORD</code> (32 bits) qui se situe là bas. Qu’y a-t-il à <code class="highlighter-rouge">EBP + 0xc</code> ? Un petit schéma de l’état de la pile s’impose</p>

<p><img src="/assets/uploads/2015/04/img_553826170a520.png" alt="stack" /></p>

<p>Avant l’appel de la fonction, les deux variables <code class="highlighter-rouge">0x2</code> et <code class="highlighter-rouge">0x28</code> ont été poussées sur la pile. Ensuite <code class="highlighter-rouge">EIP</code> a été poussé pendant le <code class="highlighter-rouge">call</code> et enfin <code class="highlighter-rouge">EBP</code>, ce qui explique le schéma précédent. Je vous rappelle que la pile part des adresses hautes et grandit en direction des adresses basses, mais qu’une variable en mémoire est lue dans le sens classique, donc des adresses basses vers les adresses hautes. La variable située à l’adresse <code class="highlighter-rouge">EBP - 0xc</code> a une taille de 4 octets. Ces 4 octets sont <code class="highlighter-rouge">EBP - 0xc + 0x0</code>, <code class="highlighter-rouge">EBP - 0xc + 0x1</code>, <code class="highlighter-rouge">EBP - 0xc + 0x2</code> et <code class="highlighter-rouge">EBP - 0xc + 0x3</code>.</p>

<p>Dans le schéma précédent, à <code class="highlighter-rouge">EBP</code> on trouve la valeur de la sauvegarde du <code class="highlighter-rouge">EBP</code> de la fonction appelante. Puis à <code class="highlighter-rouge">EBP - 0x4</code> se trouve la sauvegarde de EIP, à <code class="highlighter-rouge">EBP - 0x8</code> se trouve une des valeurs poussées avant le <code class="highlighter-rouge">call</code> et à <code class="highlighter-rouge">EBP - 0xc</code> se trouve la deuxième valeur. On monte comme ça de 4 en 4 car ces variablez sont des adresses (EBP et EIP) ou des entiers donc ils prennent 4 octets en mémoire.</p>

<p>EAX va donc valloir <code class="highlighter-rouge">0x2</code> et <code class="highlighter-rouge">EDX</code> va recevoir la valeur <code class="highlighter-rouge">0x28</code>. Nous avons vu que la ligne suivante <code class="highlighter-rouge">+12</code> additionnait les deux valeurs et enregistrait le résultat dans <code class="highlighter-rouge">EAX</code></p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">add</span>    <span class="n">eax</span><span class="p">,</span><span class="n">edx</span>
</code></pre></div></div>

<p>Les deux lignes qui suivent sont un petit peu plus complexes à comprendre</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x080483ea &lt;+14&gt;:    mov    DWORD PTR [ebp-0x4],eax
0x080483ed &lt;+17&gt;:    mov    eax,DWORD PTR [ebp-0x4]
</code></pre></div></div>

<p>La première ligne <code class="highlighter-rouge">+14</code> permet de sauvegarder le résultat du calcul en case <code class="highlighter-rouge">ebp-0x4</code>, première case libre de la stackframe. La seconde permet de récupérer cette valeur, et la met dans <code class="highlighter-rouge">EAX</code>. Conventionnellement, <code class="highlighter-rouge">EAX</code> est le registre utilisé pour enregistrer le résultat d’une fonction que l’on veut retourner (<code class="highlighter-rouge">return something;</code>).</p>

<p>Les deux dernières lignes <code class="highlighter-rouge">+20</code> et <code class="highlighter-rouge">+21</code> permettent de retrouver l’état des registres avant d’exécuter la fonction.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">leave</span> <span class="err"> </span>
<span class="k">ret</span> 
</code></pre></div></div>

<p>L’instruction <code class="highlighter-rouge">LEAVE</code> est en fait un condensé des deux opérations suivantes, comme nous l’avons vu au début de cet article :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">MOV</span> <span class="n">ESP</span><span class="p">,</span> <span class="n">EBP</span>
<span class="k">POP</span> <span class="n">EBP</span>
</code></pre></div></div>

<p>La première permet de rebaser le sommet de la pile au niveau de <code class="highlighter-rouge">EBP</code>, donc ça supprime tout le reste de la pile, et la deuxième permet de récupérer l’ancienne valeur de <code class="highlighter-rouge">EBP</code> pour pouvoir retourner à la fonction <code class="highlighter-rouge">main</code>. Pour cela, la fonction <code class="highlighter-rouge">RET</code>, équivalente à l’opération suivante :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">POP</span> <span class="n">EIP</span>
</code></pre></div></div>

<p>permet de récupérer la valeur de <code class="highlighter-rouge">EIP</code> sauvegardée lors du <code class="highlighter-rouge">call</code>, et saute à cette instruction pour continuer la suite du programme :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x0804840c &lt;+26&gt;:    mov    DWORD PTR [ebp-0x4],eax
0x0804840f &lt;+29&gt;:    mov    eax,DWORD PTR [ebp-0x4]
</code></pre></div></div>

<p>Nous avons vu précédemment que le résultat de <code class="highlighter-rouge">add</code> était retourné dans <code class="highlighter-rouge">EAX</code>. Ce résultat est sauvegardé dans la première case de la stackframe, puis est à nouveau assignée à <code class="highlighter-rouge">EAX</code> exactement comme la fin de la fonction <code class="highlighter-rouge">add</code>. Encore une fois, cela signifie que c’est la valeur de retour de la fonction main.</p>

<p>Nous quittons ensuite la fonction <code class="highlighter-rouge">main</code> comme nous avons quitté la fonction <code class="highlighter-rouge">add</code> :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x080483f0 &lt;+20&gt;:    leave  
0x080483f1 &lt;+21&gt;:    ret
</code></pre></div></div>

<p>Parfait ! Nous avons tout vu !</p>

<p>Avez-vous deviné le code C du programme après cette étude ? Deux nombres <code class="highlighter-rouge">0x2</code> (2) et <code class="highlighter-rouge">0x28</code> (40) sont envoyés à la fonction <code class="highlighter-rouge">add</code>, qui retourne leur somme, que retourne également la fonction <code class="highlighter-rouge">main</code> :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">##include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">answer</span><span class="p">;</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Vous aviez la même chose ? Félicitations ! J’espère que cet article vous aura été utile. Si des notions ou des paragraphes ont besoin d’être clarifiés, n’hésitez pas à poster des commentaires, je suis ouvert à toutes propositions !</p>

  </article>
</div>
<div class="keywords">
    <span class="post-tags"><a href="/archives/#linux"><i class="fas fa-tags"></i> Linux</a></span>
  </div>


<br />
<div class="box">
  <div class="dash">
    <div class="picture">
      <img src="/assets/icones/pixis_logo.png" alt="logo" title="logo" />
    </div>
    <div class="box_content">
      <strong>Auteur</strong> : <a href="/contact/" target="_blank">Pixis</a><br />
      Créateur du blog, suivez-moi sur <a href="https://twitter.com/HackAndDo/" target="_blank">twitter</a> ou <a href="https://discord.gg/9At6SUZ" target="blank">discord</a>
    </div>
    
  </div>
</div>


<div class="related">
  <h2>Articles similaires</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/pass-the-hash/">
            Pass the Hash
            <small>18 Dec 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/remote-lsass-dump-passwords/">
            Extraction des secrets de lsass à distance
            <small>28 Nov 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/bloodhound/">
            BloodHound
            <small>30 Jul 2019</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    
    var disqus_config = function () {
        this.page.url = 'http://localhost:4000/assembleur-notions-de-base/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '0000-0000-0000-000A';
    };
    
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//hackndo.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

        </div>
    </main>
    <script src="/assets/js/jquery-2.1.4.js"></script>
    <script src="/assets/js/jquery.menu-aim.js"></script>
    <script src="/assets/js/anchor.min.js"></script>
    <script src="/assets/js/main.js"></script> <!-- Resource jQuery -->
  </body>
</html>