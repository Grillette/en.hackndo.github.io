<!doctype html>
<html lang="fr-fr" class="no-js">

  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile" hreflang="fr">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
    <meta name="google-site-verification" content="JeRPv2CEcpONAy8C7dMr1nzjlpZxlxYCtt2PnuQ78g8" />
    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  
    <title>
      
        Gestion de la mémoire - hackndo
      
    </title>

	<link rel="stylesheet" href="/assets/css/style.css?v=1.13"> <!-- Resource style -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Signika:600"> <!-- Logo font -->
    <script src="/assets/js/modernizr.js"></script> <!-- Modernizr -->
    
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/icones/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/icones/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/icones/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/icones/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/icones/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/icones/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/icones/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/icones/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icones/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icones/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icones/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/icones/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icones/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/res/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/icones/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  	
	<!-- RSS -->
    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="hackndo" />

    <!-- Twitter card -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@hackanddo" />
    <meta name="twitter:creator" content="@hackanddo" />
    <meta name="twitter:title" content="Gestion de la mémoire" />
    <meta name="twitter:description" content="Aujourd'hui, je vais tenter de rassembler tout ce que j'ai pu comprendre sur la gestion de la mémoire lors de l'exécution d'un programme." />
    
    <meta name="twitter:image" content="http://localhost:4000/assets/uploads/2015/01/hacking.jpg" />
    
  
    <!-- Google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
      ga('create', 'UA-80312745-1', 'auto');
      ga('send', 'pageview');
  
    </script>
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Gestion de la mémoire" />
<meta name="author" content="Pixis" />
<meta property="og:locale" content="fr_FR" />
<meta name="description" content="Aujourd’hui, je vais tenter de rassembler tout ce que j’ai pu comprendre sur la gestion de la mémoire lors de l’exécution d’un programme." />
<meta property="og:description" content="Aujourd’hui, je vais tenter de rassembler tout ce que j’ai pu comprendre sur la gestion de la mémoire lors de l’exécution d’un programme." />
<link rel="canonical" href="http://localhost:4000/gestion-de-la-memoire/" />
<meta property="og:url" content="http://localhost:4000/gestion-de-la-memoire/" />
<meta property="og:site_name" content="hackndo" />
<meta property="og:image" content="http://localhost:4000/assets/uploads/2015/01/hacking.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-01-11T00:00:00+01:00" />
<script type="application/ld+json">
{"image":"http://localhost:4000/assets/uploads/2015/01/hacking.jpg","@type":"BlogPosting","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/icones/logo.png"},"name":"Pixis"},"url":"http://localhost:4000/gestion-de-la-memoire/","headline":"Gestion de la mémoire","dateModified":"2015-01-11T00:00:00+01:00","datePublished":"2015-01-11T00:00:00+01:00","author":{"@type":"Person","name":"Pixis"},"description":"Aujourd’hui, je vais tenter de rassembler tout ce que j’ai pu comprendre sur la gestion de la mémoire lors de l’exécution d’un programme.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/gestion-de-la-memoire/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

  <body>
    <header class="cd-main-header">
    <a href="/" class="cd-logo"><img src="/assets/icones/logo.png" /> <span class="cd-logo-title">hackndo</span></a>
		
    <a href="#0" class="cd-nav-trigger">Menu<span></span></a>

</header> <!-- .cd-main-header -->
    <main class="cd-main-content">
		<nav class="cd-side-nav">
            <div class="sidebar-about">
    <h1>
        <img id="site-logo" src="/assets/icones/logo.png" alt="logo" title="logo" />
        <a class="sidebar-title" href="/">
        hackndo
        </a>
    </h1>
    <p class="lead">Think out of the box</p>
</div>

<ul>
    <li class="cd-label">Blog</li>
    <li class="">
        <a href="/">Home</a>
    </li>
    
    
        
            
        
    
        
            
                <li class="">
                    <a href="/about/">À propos</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/archives/">Archives</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/contact/">Me contacter</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/disclaimer/">Disclaimer</a>
                </li>
            
        
    
        
    
        
            
        
    
        
            
                <li class="">
                    <a href="/projects/">Projets</a>
                </li>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
    
        
    
</ul>
<ul>
    <li class="cd-label">Liens</li>
    <li><a href="https://www.dailysecurity.fr/" target="_blank">Blog de Geluchat</a></li>
    <li><a href="http://lsdsecdaemon.com" target="_blank">Blog de Th3_l5D</a></li>
    <li><a href="http://inf0sec.fr" target="_blank">Blog de Matthieu</a></li>
</ul>
<p class="sidebar-copyright">&copy; 2019. Tous droits réservés.</p>
<div class="sidebar-social">
<ul>
  <li><a href="https://twitter.com/HackAndDo" title="Twitter" target="_blank"><img alt="Twitter" title="Twitter" src="/assets/icones/social/twitter.png" /></a></li>
  <li><a href="https://github.com/hackndo" title="Github" target="_blank"><img title="Github" alt="Github" src="/assets/icones/social/github.png" /></a></li>
  <li><a href="https://www.youtube.com/channel/UC9WYWHLdu9TK-0Hu3wcHJ9g" title="Youtube" target="_blank"><img title="Youtube" alt="Youtube" src="/assets/icones/social/youtube.png" /></a></li>
  <li><a href="https://discord.gg/9At6SUZ" title="Discord" target="_blank"><img title="Discord" alt="Discord" src="/assets/icones/social/discord.png" /></a></li>
  <li><a href="https://www.linkedin.com/in/romainbentz/" title="LinkedIn" target="_blank"><img title="LinkedIn" alt="LinkedIn" src="/assets/icones/social/linkedin.png" /></a></li>
  <li><a href="https://sh.hackndo.com" title="Shell" target="_blank"><img title="Shell" alt="Shell" src="/assets/icones/social/shell.png" /></a></li>
  <li><a href="/feed.xml" title="RSS" target="_blank"><img title="RSS" alt="RSS" src="/assets/icones/social/rss.png" /></a></li>
  <li><a href="https://ko-fi.com/hackndo" title="Ko-Fi" target="_blank"><img title="Ko-Fi" alt="Ko-Fi" src="/assets/icones/social/kofi.gif" /></a></li>
</ul>
</div>
        </nav>

        <div class="content-wrapper">
            <div class="post">
  
  <div class="post-cover">
    <img src="/assets/uploads/2015/01/hacking.jpg" alt="Gestion de la mémoire" title="Gestion de la mémoire" />
  </div>
  
  <h1 class="post-title">Gestion de la mémoire</h1>
  <div class="post-info">
      <p class="alignleft">11 Jan 2015 <a class="post-comments-count" href="http://http://localhost:4000/gestion-de-la-memoire/#disqus_thread"></a></p>
      <p class="alignright">Auteur : <strong><a href="https://twitter.com/HackAndDo">Pixis</a></strong></p>
      <div class="keywords">
        <span class="post-tags"><a href="/archives/#user-land"><i class="fas fa-tags"></i> User Land</a><a href="/archives/#linux"><i class="fas fa-tags"></i> Linux</a></span>
      </div>
</div>

  <article>
  <p>Aujourd’hui, je vais tenter de rassembler tout ce que j’ai pu comprendre sur la gestion de la mémoire lors de l’exécution d’un programme. Cet article est écrit en vu de comprendre l’exploitation de certaines failles applicatives, telles que le <em>buffer overflow</em>, le <em>heap overflow</em> ou encore la <em>format string</em>, failles que je décrirai dans les prochains articles.</p>

<!--more-->

<h2 id="mémoire-virtuelle">Mémoire virtuelle</h2>

<p>Les processus tournant sur une machine ont besoin de mémoire, et dans un ordinateur, la quantité de mémoire est limitée. Il faut donc que les processus aillent chercher de la mémoire disponible pour pouvoir travailler. Cependant, les processus tournent de nos jours dans des systèmes d’exploitation multi-tâches. Plusieurs processus s’exécutent en même temps. Que se passerait-il si deux processus voulaient accéder, au même instant, à la même zone mémoire ? Et surtout, si jamais un processus écrivait dans une zone mémoire, puis un autre processus écrasait cette même zone mémoire avec ses propres données, alors le processus A, le pauvre, pensera retrouver ses données, mais il trouvera en fait les données de B. Et là, c’est le drame ! Il faudrait alors que les processus communiquent en permanence entre eux pour savoir qui fait quoi, où et quand. Ce serait une vraie perte de temps et d’une complexité effroyable pour ce problème.</p>

<p><a href="/assets/uploads/2015/01/img_54b50cc491e11.png"><img src="/assets/uploads/2015/01/img_54b50cc491e11.png" alt="img_54b50cc491e11" /></a></p>

<p>C’est là qu’intervient la mémoire virtuelle : Les processus ne vont plus piocher directement dans la mémoire physique. On les met dans des bacs à sable (<em>sand box</em>), en leur allouant une plage de mémoire <strong>virtuelle</strong> (de 4Go pour les machines 32 bits), en leur faisant croire qu’ils sont les seuls à s’exécuter sur la machine. C’est alors que le kernel intervient, et effectue le lien entre les différentes plages de mémoires virtuelles et la mémoire réelle. Ceci est fait par le biais de tables de pages (<em>page tables</em>). Voici un schéma pour y voir plus clair :</p>

<p><a href="/assets/uploads/2015/01/img_54b50ce3eda87.png"><img src="/assets/uploads/2015/01/img_54b50ce3eda87.png" alt="img_54b50ce3eda87" /></a></p>

<p>Le processus n’a alors plus à se soucier de l’implémentation de la mémoire. Toutes les opérations bas niveau sont gérées par le noyau de l’OS. C’est une sorte de couche d’abstraction qui simplifie la vie du processus.</p>

<p>Chaque processus a sa propre table de pages. Cependant, si l’adressage virtuel est activé, il s’applique à tous les programmes qui tournent sur la machine, <strong>kernel compris</strong>. Ainsi, il faut réserver une portion de l’espace virtuel de chaque programme pour le noyau !</p>

<h2 id="segmentation-de-la-mémoire">Segmentation de la mémoire</h2>

<p>Ainsi, nous allons voir ici comment est <strong>segmentée</strong> la mémoire d’un programme compilé lorsqu’il est chargé en mémoire afin de créer un processus (Son <strong>image</strong>, une sorte d’instance, si ça vous parle).</p>

<p>On retrouve les 3 sections suivantes :</p>

<ol>
  <li>Texte (<em>.text</em>)</li>
  <li>Données (<em>.data</em>)</li>
  <li>bss (<em>.bss</em>)</li>
</ol>

<p>Et les 2 zones mémoire suivantes :</p>

<ol>
  <li>Tas (<em>heap</em>)</li>
  <li>Pile (<em>stack</em>)</li>
</ol>

<p><a href="/assets/uploads/2015/01/img_54b40db038230.png"><img src="/assets/uploads/2015/01/img_54b40db038230.png" alt="img_54b40db038230" /></a></p>

<p>Chacune de ces zones représente une partie de la mémoire allouée au processus en question.</p>

<p>Rapidement, la première <strong>section</strong> <strong>texte</strong> (.<em>text</em>) est celle qui contient le code du programme, et plus exactement les instructions en langage machine. C’est une section en lecture seule, une fois qu’elle a été définie, elle est immuable. Elle sert seulement à stocker du code, pas des variables. Des erreurs de programmation peuvent entraîner cette fameuse erreur : “Segmentation Fault”, qui indique à l’utilisateur qu’une écriture non autorisée a tenté d’être faite dans cette zone mémoire.</p>

<p>Du fait de son immuabilité, c’est une zone mémoire de taille fixe. Le programme démarrera donc au début de ce segment, puis il va lire les instructions une par une. Cependant, cette lecture n’est pas linéaire. En effet, avec le code haut niveau que nous produisons, il existe beaucoup de structures de contrôles qui engendrent des appels à des bout de code qui ne sont pas les uns à la suite des autres. On expliquera par la suite comment l’exécution du programme fonctionne, notamment avec l’aide des registres.</p>

<p>La section de <strong>données</strong> (<em>data</em>) et la section <strong>bss</strong> stockent les variables globales et statiques du programme. Si ces données sont initialisées, elles sont enregistrées dans la section <em>data</em>, tandis que les autres sont dans la section bss. Ce sont également des zones mémoires de taille fixe. Malgré la possibilité en écriture, les variables finales et statiques ne changeront pas au cours de l’exécution du programme ou du contexte. C’est parce qu’elles sont dans cette zone mémoire qu’elles peuvent persister.</p>

<p>Nous pouvons prendre un exemple en C. Soit le programme suivant, vide. examinons la taille de ses différentes sections.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hackndo@becane:~/exemples<span class="nv">$ </span>gcc memory.c <span class="nt">-o</span> memory
hackndo@becane:~/exemples<span class="nv">$ </span>size memory

text data bss dec  hex filename
1073 560  8   1641 669 memory
</code></pre></div></div>

<p>Maintenant, ajoutons une variable globale non initialisée et étudions les tailles des différentes sections à nouveau</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="n">global</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hackndo@becane:~/exemples<span class="nv">$ </span>gcc memory.c <span class="nt">-o</span> memory
hackndo@becane:~/exemples<span class="nv">$ </span>size memory

text data bss dec  hex filename
1073 560  12  1641 669 memory
</code></pre></div></div>

<p>On remarque que la section bss a augmenté de 4 octets pour stocker la variable statique non-initialisée. Si de la même manière on ajoute une variable statique à l’intérieur de la fonction <code class="highlighter-rouge">main()</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="n">global</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">var</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hackndo@becane:~/exemples<span class="nv">$ </span>gcc memory.c <span class="nt">-o</span> memory
hackndo@becane:~/exemples<span class="nv">$ </span>size memory

text data bss dec  hex filename
1073 560  16  1641 669 memory
</code></pre></div></div>

<p>Encore une fois, on remarque que bss a augmenté de 4 octets pour stocker cette variable. Si maintenant on initialise la variable <code class="highlighter-rouge">var</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="n">global</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">var</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hackndo@becane:~/exemples<span class="nv">$ </span>gcc memory.c <span class="nt">-o</span> memory
hackndo@becane:~/exemples<span class="nv">$ </span>size memory

text data bss dec  hex filename
1073 564  12  1641 669 memory
</code></pre></div></div>

<p>Cette fois-ci, la variable n’est plus stockée dans la section bss, mais dans la section data, puisqu’on remarque qu’elle est passée de 560 à 564 alors que la section bss a diminué de 4 octets. Enfin, si on initialise également la variable globale <code class="highlighter-rouge">global</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="n">global</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">var</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hackndo@becane:~/exemples<span class="nv">$ </span>gcc memory.c <span class="nt">-o</span> memory
hackndo@becane:~/exemples<span class="nv">$ </span>size memory

text data bss dec  hex filename
1073 568  8   1641 669 memory
</code></pre></div></div>

<p>Les deux variables sont stockées dans la section data, et non plus dans la section bss.</p>

<p>Le <strong>tas</strong> (<em>heap</em>) est, quant à lui, manipulable par le programmeur. C’est la zone dans laquelle sont écrites les zones mémoires allouées dynamiquement (<em>malloc()</em> ou <em>calloc()</em>). Tout comme la pile, cette zone mémoire n’a pas de taille fixe. Elle augmente et diminue en fonction des demandes du programmeur, qui peut réserver ou supprimer des blocs via des algorithmes d’allocation ou de libération pour une utilisation future. Plus la taille du tas augmente, plus les adresses mémoires augmentent, et s’approchent des adresses mémoires de la pile. La taille des variables dans le tas n’est pas limitée (sauf limite physique de la mémoire), contrairement à la pile.</p>

<p>Par ailleurs, les variables stockées dans le tas sont accessibles partout dans le programme, par l’intermédiaire des pointeurs. Cependant, l’accès aux variables stockées dans le tas ne se faisant qu’avec des pointeurs, cela ralentit un peu ces accès, contrairement aux accès dans la pile.</p>

<p>La <strong>pile</strong> (<em>stack</em>) possède également une taille variable, mais plus sa taille augmente, plus les adresses mémoires diminuent, en s’approchant du haut du tas. C’est ici qu’on retrouve les variables locales des fonctions ainsi que le cadre de pile (<em>stack frame</em>) de ces fonctions. La <em>stack frame</em> d’une fonction est une zone mémoire, dans la pile, dans laquelle toutes les informations, nécessaires à l’appel de cette fonction, sont stockées. S’y trouvent également les variables locales de la fonction.</p>

<p>Vous avez donc j’espère une idée plus claire de la segmentation de la mémoire lors de l’exécution d’un programme. Cependant il manque une notion importante qui est la gestion des registres. En expliquant leur fonctionnement et leur utilité, nous seront à même de mieux comprendre la notion de stack frame.</p>

<h2 id="registres">Registres</h2>

<p>Les registres sont des emplacements mémoire qui sont à l’intérieur du processeur. Or dans un ordinateur, les emplacements mémoire les plus proches du processeur sont ceux à qui il est le plus rapide d’accéder, mais également les plus chers. Ainsi, plus on s’éloigne du processeur, plus les accès sont longs, mais les coûts sont faibles. Les registres sont les emplacements mémoire les plus proches (puisqu’ils sont internes au processeur), c’est alors la mémoire la plus rapide de l’ordinateur. Cette pyramide de la mémoire est représentée dans la figure suivante, qui oppose le coût de la mémoire à son temps d’accès par le processeur :</p>

<p><a href="/assets/uploads/2015/01/img_54b3b77f84d31.png"><img src="/assets/uploads/2015/01/img_54b3b77f84d31.png" alt="img_54b3b77f84d31" /></a></p>

<p>Le processeur x86 32 bits possède (logiquement) 8 registres généraux (EAX, EBX, ECX, EDX, ESP, EBP, ESI, EDI)</p>

<p><em>Pour les processeurs 64 bits, il y a 16 registres logiques. Mais dans la réalité, les derniers processeurs en ont 168, pour pouvoir paralléliser les instructions.</em></p>

<p>On distingue deux groupes :</p>

<ul>
  <li>Les 4 EAX, EBX, ECX et EDX appelés <strong>A</strong>ccumulateur, <strong>B</strong>ase, <strong>C</strong>ompteur, <strong>D</strong>onnées ont pour rôle de stocker des données temporaires pour le processeur lorsqu’il exécute un programme.</li>
  <li>Les 4 autres registres ESP, EBP, ESI et EDI appelés <strong>P</strong>ointeur de Pile (<strong>S</strong>tack), <strong>P</strong>ointeur de <strong>B</strong>ase, <strong>I</strong>ndex de <strong>S</strong>ource et <strong>I</strong>ndex de <strong>D</strong>estination sont plutôt utilisés en tant que pointeurs et index, comme leur nom l’indique. Par exemple, les deux premiers stockent des adresses 32 bits (désignant des emplacements mémoire) pour délimiter le stack frame courant.</li>
</ul>

<p>Nous avons également deux autres registres, un peu plus spéciaux :</p>

<ul>
  <li>Le registre EIP est appelé <strong>P</strong>ointeur d’<strong>I</strong>nstruction. Il contient l’adresse de la prochaine instruction que le processeur doit exécuter.</li>
  <li>Enfin, le registre EFLAGS qui, en réalité, contient des indicateurs, des interrupteurs, des drapeaux (<em>flags</em>) essentiellement utilisés pour des comparaisons, mais pas uniquement.</li>
</ul>

<p>Pour aller plus loin, vous pouvez lire l’article sur <a href="/fonctionnement-de-la-pile">le fonctionnement de la pile</a>.</p>

  </article>
</div>
<div class="keywords">
    <span class="post-tags"><a href="/archives/#user-land"><i class="fas fa-tags"></i> User Land</a><a href="/archives/#linux"><i class="fas fa-tags"></i> Linux</a></span>
  </div>


<br />
<div class="box">
  <div class="dash">
    <div class="picture">
      <img src="/assets/icones/pixis_logo.png" alt="logo" title="logo" />
    </div>
    <div class="box_content">
      <strong>Auteur</strong> : <a href="/contact/" target="_blank">Pixis</a><br />
      Créateur du blog, suivez-moi sur <a href="https://twitter.com/HackAndDo/" target="_blank">twitter</a> ou <a href="https://discord.gg/9At6SUZ" target="blank">discord</a>
    </div>
    
  </div>
</div>


<div class="related">
  <h2>Articles similaires</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/pass-the-hash/">
            Pass the Hash
            <small>18 Dec 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/remote-lsass-dump-passwords/">
            Extraction des secrets de lsass à distance
            <small>28 Nov 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/bloodhound/">
            BloodHound
            <small>30 Jul 2019</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    
    var disqus_config = function () {
        this.page.url = 'http://localhost:4000/gestion-de-la-memoire/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '0000-0000-0000-000F';
    };
    
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//hackndo.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

        </div>
    </main>
    <script src="/assets/js/jquery-2.1.4.js"></script>
    <script src="/assets/js/jquery.menu-aim.js"></script>
    <script src="/assets/js/anchor.min.js"></script>
    <script src="/assets/js/main.js"></script> <!-- Resource jQuery -->
  </body>
</html>