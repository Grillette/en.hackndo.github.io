<!doctype html>
<html lang="fr-fr" class="no-js">

  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile" hreflang="fr">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
    <meta name="google-site-verification" content="JeRPv2CEcpONAy8C7dMr1nzjlpZxlxYCtt2PnuQ78g8" />
    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  
    <title>
      
        Padding oracle - hackndo
      
    </title>

	<link rel="stylesheet" href="/assets/css/style.css?v=1.13"> <!-- Resource style -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Signika:600"> <!-- Logo font -->
    <script src="/assets/js/modernizr.js"></script> <!-- Modernizr -->
    
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/icones/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/icones/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/icones/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/icones/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/icones/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/icones/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/icones/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/icones/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icones/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icones/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icones/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/icones/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icones/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/res/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/icones/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  	
	<!-- RSS -->
    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="hackndo" />

    <!-- Twitter card -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@hackanddo" />
    <meta name="twitter:creator" content="@hackanddo" />
    <meta name="twitter:title" content="Padding oracle" />
    <meta name="twitter:description" content="Nous allons dans cet article parler de la technique d'attaque du padding oracle, en utilisant le padding d'un message chiffré suite à un chiffrement par bloc utilisant le mode CBC." />
    
    <meta name="twitter:image" content="http://localhost:4000/assets/uploads/2017/02/sc1.png" />
    
  
    <!-- Google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
      ga('create', 'UA-80312745-1', 'auto');
      ga('send', 'pageview');
  
    </script>
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Padding oracle" />
<meta name="author" content="Pixis" />
<meta property="og:locale" content="fr_FR" />
<meta name="description" content="Nous allons dans cet article parler de la technique d’attaque du padding oracle, en utilisant le padding d’un message chiffré suite à un chiffrement par bloc utilisant le mode CBC." />
<meta property="og:description" content="Nous allons dans cet article parler de la technique d’attaque du padding oracle, en utilisant le padding d’un message chiffré suite à un chiffrement par bloc utilisant le mode CBC." />
<link rel="canonical" href="http://localhost:4000/padding-oracle/" />
<meta property="og:url" content="http://localhost:4000/padding-oracle/" />
<meta property="og:site_name" content="hackndo" />
<meta property="og:image" content="http://localhost:4000/assets/uploads/2017/02/sc1.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-02-10T17:59:25+01:00" />
<script type="application/ld+json">
{"image":"http://localhost:4000/assets/uploads/2017/02/sc1.png","@type":"BlogPosting","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/icones/logo.png"},"name":"Pixis"},"url":"http://localhost:4000/padding-oracle/","headline":"Padding oracle","dateModified":"2017-02-10T17:59:25+01:00","datePublished":"2017-02-10T17:59:25+01:00","author":{"@type":"Person","name":"Pixis"},"description":"Nous allons dans cet article parler de la technique d’attaque du padding oracle, en utilisant le padding d’un message chiffré suite à un chiffrement par bloc utilisant le mode CBC.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/padding-oracle/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

  <body>
    <header class="cd-main-header">
    <a href="/" class="cd-logo"><img src="/assets/icones/logo.png" /> <span class="cd-logo-title">hackndo</span></a>
		
    <a href="#0" class="cd-nav-trigger">Menu<span></span></a>

</header> <!-- .cd-main-header -->
    <main class="cd-main-content">
		<nav class="cd-side-nav">
            <div class="sidebar-about">
    <h1>
        <img id="site-logo" src="/assets/icones/logo.png" alt="logo" title="logo" />
        <a class="sidebar-title" href="/">
        hackndo
        </a>
    </h1>
    <p class="lead">Think out of the box</p>
</div>

<ul>
    <li class="cd-label">Blog</li>
    <li class="">
        <a href="/">Home</a>
    </li>
    
    
        
            
        
    
        
            
                <li class="">
                    <a href="/about/">À propos</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/archives/">Archives</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/contact/">Me contacter</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/disclaimer/">Disclaimer</a>
                </li>
            
        
    
        
    
        
            
        
    
        
            
                <li class="">
                    <a href="/projects/">Projets</a>
                </li>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
    
        
    
</ul>
<ul>
    <li class="cd-label">Liens</li>
    <li><a href="https://www.dailysecurity.fr/" target="_blank">Blog de Geluchat</a></li>
    <li><a href="http://lsdsecdaemon.com" target="_blank">Blog de Th3_l5D</a></li>
    <li><a href="http://inf0sec.fr" target="_blank">Blog de Matthieu</a></li>
</ul>
<p class="sidebar-copyright">&copy; 2019. Tous droits réservés.</p>
<div class="sidebar-social">
<ul>
  <li><a href="https://twitter.com/HackAndDo" title="Twitter" target="_blank"><img alt="Twitter" title="Twitter" src="/assets/icones/social/twitter.png" /></a></li>
  <li><a href="https://github.com/hackndo" title="Github" target="_blank"><img title="Github" alt="Github" src="/assets/icones/social/github.png" /></a></li>
  <li><a href="https://www.youtube.com/channel/UC9WYWHLdu9TK-0Hu3wcHJ9g" title="Youtube" target="_blank"><img title="Youtube" alt="Youtube" src="/assets/icones/social/youtube.png" /></a></li>
  <li><a href="https://discord.gg/9At6SUZ" title="Discord" target="_blank"><img title="Discord" alt="Discord" src="/assets/icones/social/discord.png" /></a></li>
  <li><a href="https://www.linkedin.com/in/romainbentz/" title="LinkedIn" target="_blank"><img title="LinkedIn" alt="LinkedIn" src="/assets/icones/social/linkedin.png" /></a></li>
  <li><a href="https://sh.hackndo.com" title="Shell" target="_blank"><img title="Shell" alt="Shell" src="/assets/icones/social/shell.png" /></a></li>
  <li><a href="/feed.xml" title="RSS" target="_blank"><img title="RSS" alt="RSS" src="/assets/icones/social/rss.png" /></a></li>
  <li><a href="https://ko-fi.com/hackndo" title="Ko-Fi" target="_blank"><img title="Ko-Fi" alt="Ko-Fi" src="/assets/icones/social/kofi.gif" /></a></li>
</ul>
</div>
        </nav>

        <div class="content-wrapper">
            <div class="post">
  
  <div class="post-cover">
    <img src="/assets/uploads/2017/02/sc1.png" alt="Padding oracle" title="Padding oracle" />
  </div>
  
  <h1 class="post-title">Padding oracle</h1>
  <div class="post-info">
      <p class="alignleft">10 Feb 2017 <a class="post-comments-count" href="http://http://localhost:4000/padding-oracle/#disqus_thread"></a></p>
      <p class="alignright">Auteur : <strong><a href="https://twitter.com/HackAndDo">Pixis</a></strong></p>
      <div class="keywords">
        <span class="post-tags"><a href="/archives/#crypto"><i class="fas fa-tags"></i> Crypto</a></span>
      </div>
</div>

  <article>
  <p>Nous allons dans cet article parler de la technique d’attaque du padding oracle, en utilisant le padding d’un message chiffré suite à un chiffrement par bloc utilisant le mode CBC.</p>

<!--more-->

<p>Il existe deux grandes familles de chiffrement. Les chiffrements symétriques pour lesquels une même clé est utilisée pour le chiffrement et le déchiffrement, et les chiffrements asymétriques qui possèdent une clé pour le chiffrement et une autre pour le déchiffrement.</p>

<p>En ce qui concerne les chiffrement symétrique, les données peuvent être chiffrées de deux manières. Il existe les chiffrements de flux, c’est à dire qu’une longueur quelconque de donnée peut être chiffrée, les données n’ont pas besoins d’être découpées. L’autre manière est le chiffrement par blocs. Dans ce cas là, les données sont découpées en blocs de taille fixe afin de pouvoir être chiffrées.</p>

<p>Enfin, différents modes d’opérations sont possibles pour le chiffrement par bloc, tels que CBC, ECB, CFB etc.</p>

<p>Cependant, le chiffrement par bloc lève deux questions</p>

<ul>
  <li>Que se passe-t-il si la taille du message à chiffrer n’est pas un multiple de la taille d’un bloc ? Donc que se passe-t-il si le dernier bloc a une taille inférieure aux autres blocs ?</li>
  <li>Que se passe-t-il si une fois le texte clair découpé, deux blocs clairs sont identiques ? Leur chiffrement ne doit pas donner deux résultats similaires car d’un point de vue cryptographique, un attaquant pourra deviner que des morceaux du texte clair sont identiques, ce qui n’est pas souhaitable.</li>
</ul>

<p>Nous allons dans cet article nous intéresser au mode CBC du chiffrement par blocs qui permet de répondre à la deuxième question.</p>

<h2 id="fonctionnement-du-mode-cbc">Fonctionnement du mode CBC</h2>

<h3 id="padding">Padding</h3>

<p>Alors que nous avons parlé du padding utilisé par les fonctions de hashage dans l’article sur le <a href="http://beta.hackndo.com/hash-length-extension" target="blank">Hash Length Extension</a>, nous allons ici nous intéresser à une technique de padding majoritairement utilisée dans les chiffrements par blocs, <a href="https://en.wikipedia.org/wiki/PKCS" target="blank">PKCS</a>7 dont le fonctionnement est décrit dans la <a href="https://tools.ietf.org/html/rfc5652#section-6.3" target="blank">RFC 5652</a>.</p>

<p>Soit N octets la taille d’un bloc. S’il manque M octets dans le dernier bloc, alors on ajoutera le charactère ‘0xM’ M fois à la fin du bloc.</p>

<p>Par exemple, si nous avons des blocs de taille 8 octets et que nous avons le texte clair suivant :</p>

<p><code class="highlighter-rouge">"Love hackndo"</code></p>

<p>Le découpage donnera</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"Love hac"
"kndo"
</code></pre></div></div>

<p>Il manque alors 4 octets pour que le dernier bloc “kndo” fasse 8 octets. Le padding sera alors le suivant</p>

<p><code class="highlighter-rouge">"kndo\x04\x04\x04\x04"</code>-</p>

<p>Dans le cas où la taille du texte est un multiple de la taille d’un bloc, alors un bloc entier de padding est ajouté à la suite du texte clair. En effet, imaginons deux données en clair :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Données 1
"\x41\x42\x41\x42\x41\x42\x41\x42"
"\x43\x44\x43\x44\x43\x44\x43\x01"

# Données 2
"\x41\x42\x41\x42\x41\x42\x41\x42"
"\x43\x44\x43\x44\x43\x44\x43"
</code></pre></div></div>

<p>Dans les premières données en clair, le \x01 fait partie de l’information à transmettre. Si jamais aucun padding n’était ajouté, alors on ne pourrait pas différencier les données 1 des données 2 suite au padding. L’ajout d’un bloc complet permet ainsi de différencier ces cas.</p>

<p>Après padding, nous avons alors</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Données 1 après padding
"\x41\x42\x41\x42\x41\x42\x41\x42"
"\x43\x44\x43\x44\x43\x44\x43\x01"
"\x08\x08\x08\x08\x08\x08\x08\x08"

# Données 2 après padding
"\x41\x42\x41\x42\x41\x42\x41\x42"
"\x43\x44\x43\x44\x43\x44\x43\x01"
</code></pre></div></div>

<p>Les deux données claires après padding sont différentes, ce qui donnera des chiffrements différents, chose que l’on souhaite puisque les données initiales sont différentes.</p>

<p>Voici un petit code python qui propose deux fonctions. L’une ajoute le padding nécessaire au dernier bloc, et l’autre supprime le padding.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_padding</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size_block</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">size_block</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="n">size_block_byte</span> <span class="o">=</span> <span class="n">size_block</span><span class="o">/</span><span class="mi">8</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="n">size_block_byte</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">%</span> <span class="n">size_block_byte</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span><span class="o">*</span><span class="n">padding</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">del_padding</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="nb">ord</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>

<span class="c1"># Exemple
</span>
<span class="n">data</span> <span class="o">=</span> <span class="s">"Love hackndo!"</span>
<span class="n">data_padded</span> <span class="o">=</span> <span class="n">set_padding</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="k">print</span><span class="p">([</span><span class="n">data_padded</span><span class="p">])</span>
<span class="c1"># &gt;&gt;&gt; ['Love hackndo!\x03\x03\x03']
</span>
<span class="n">data_padding_removed</span> <span class="o">=</span> <span class="n">del_padding</span><span class="p">(</span><span class="n">data_padded</span><span class="p">)</span>
<span class="k">print</span><span class="p">([</span><span class="n">data_padding_removed</span><span class="p">])</span>
<span class="c1"># &gt;&gt;&gt; ['Love hackndo!']
</span>
<span class="n">data</span> <span class="o">=</span> <span class="s">"12345678"</span>
<span class="n">data_padded</span> <span class="o">=</span> <span class="n">set_padding</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="k">print</span><span class="p">([</span><span class="n">data_padded</span><span class="p">])</span>
<span class="c1"># &gt;&gt;&gt; ['12345678\x08\x08\x08\x08\x08\x08\x08\x08']
</span>
<span class="n">data_padding_removed</span> <span class="o">=</span> <span class="n">del_padding</span><span class="p">(</span><span class="n">data_padded</span><span class="p">)</span>
<span class="k">print</span><span class="p">([</span><span class="n">data_padding_removed</span><span class="p">])</span>
<span class="c1"># &gt;&gt;&gt; ['12345678']
</span></code></pre></div></div>

<p>Nous parlons de padding oracle non pas en lien avec Oracle l’entreprise, mais car l’oracle est la partie (souvent) serveur qui donne l’information sur la validité - ou non - du padding d’un message chiffré, permettant l’attaque dont nous allons parler par la suite.</p>

<h3 id="blocs-similaires">Blocs similaires</h3>

<p>Le mode CBC permet de pallier au problème des blocs similaires. Imaginons que nous avons des blocs de 32 bits, et que le message que nous voulons coder est le suivant “hack, or do not hack”. En découpant ce message en blocs de 32 bits (donc 4 octets), nous obtenons ces 5 blocs</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"hack"
", or"
" do "
"not "
"hack"
</code></pre></div></div>

<p>Si chaque bloc est chiffré indépendamment, alors le premier et le dernier bloc de notre message donneront le même texte chiffré, ce qui n’est pas souhaitable comme précédemment indiqué.</p>

<p>Dans le mode CBC, pour obtenir le chiffrement d’un bloc de texte clair, ce texte clair est XORé avec le texte chiffré du bloc précédant, avant d’être lui même chiffré.</p>

<p>On a alors</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bloc_n_chiffré = chiffrement(bloc_n_clair ⊕ bloc_n-1_chiffré)
</code></pre></div></div>

<p>Si vous avez bien compris ce principe, vous devriez vous demander ce qu’il se passe pour chiffrer le premier bloc, puisqu’il n’y a pas de bloc avant lui pour effectuer ce XOR.</p>

<p>Et bien pour cela, un IV (<strong>I</strong>nitialization <strong>V</strong>ector) est défini, c’est à dire une chaine aléatoire choisie pour ce chiffrement d’une taille égale à la taille d’un bloc. Cet IV permet de simuler un bloc précédant. Vous obtenez alors le schéma suivant :</p>

<p><a href="/assets/uploads/2017/02/sc1.png"><img src="/assets/uploads/2017/02/sc1.png" alt="Chiffrement CBC" /></a></p>

<p>En termes mathématiques, voici comment un chiffrement CBC fonctionne</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Pour n = 0:

bloc_n_chiffré = chiffrement(bloc_n_clair ⊕ IV)

# Pour n &gt; 0:

bloc_n_chiffré = chiffrement(bloc_n_clair ⊕ bloc_n-1_chiffré)
</code></pre></div></div>

<p>Du coup, grâce au propriétés de l’opération XOR, voici à quoi ressemble en terme mathématiques le déchiffrement</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Pour n = 0:

bloc_n_clair = déchiffrement(bloc_n_chiffré) ⊕ IV

# Pour n &gt; 0:

bloc_n_clair = déchiffrement(bloc_n_chiffré) ⊕ bloc_n-1_chiffré
</code></pre></div></div>

<h2 id="vulnérabilité-du-mode-cbc">Vulnérabilité du mode CBC</h2>

<h3 id="du-chiffrement-au-xor">Du chiffrement au XOR</h3>

<p>Maintenant que nous avons les mathématiques avec nous, nous pouvons créer et combiner quelques informations. Accrochez-vous, suivez bien, il n’y a rien de magique.</p>

<p>Prenons un exemple théorique, une chaine de caractères qui, une fois paddée, fait 5 blocs de 8 octets chacun. Les 5 blocs de plaintext sont <code class="highlighter-rouge">P_1 .. P_5</code> et les 5 blocs chiffrés sont <code class="highlighter-rouge">C_1 .. C_5</code>.</p>

<p>Nous avons donc le schéma suivant :</p>

<p><a href="/assets/uploads/2017/02/sc2.png"><img src="/assets/uploads/2017/02/sc2.png" alt="notation plaintext vs chiffré" /></a></p>

<p>Maintenant, prenons un nouveau bloc <code class="highlighter-rouge">X</code> totalement aléatoire. C’est un bloc que nous créons, que nous maitrisons, qu’on peut changer, frapper, manger. Prenons avec lui le dernier bloc chiffré de notre exemple, <code class="highlighter-rouge">C_5</code>, et concaténons les.</p>

<p>Nous avons alors le schéma suivant :</p>

<p><a href="/assets/uploads/2017/02/sc3.png"><img src="/assets/uploads/2017/02/sc3.png" alt="notation pour la concaténation" /></a></p>

<p>Nous pouvons, à l’aide de ce que nous avons vu avant, écrire <code class="highlighter-rouge">P'2</code> de la manière suivante</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Égalité 1
P'2 = déchiffrement(C_5) ⊕ X
</code></pre></div></div>

<p>Nous avons également la formule suivante pour <code class="highlighter-rouge">C_5</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Égalité 2
C_5 = chiffrement(P_5 ⊕ C_4)
</code></pre></div></div>

<p>Donc en remplaçant <code class="highlighter-rouge">C_5</code> dans l’égalité <strong>1</strong> par sa représentation dans l’égalité <strong>2</strong> on obtient</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P'2 = déchiffrement(chiffrement(P_5 ⊕ C_4)) ⊕ X

# Or déchiffrer un texte chiffré donne le texte original, donc

P'2 = P_5 ⊕ C_4 ⊕ X
</code></pre></div></div>

<p>Nous voilà avec une équation qui relie 2 éléments connus avec deux inconnues</p>

<p><strong>Connus</strong></p>

<ul>
  <li><code class="highlighter-rouge">X</code> : C’est l’élément que nous maitrisons, que nous pouvons changer, frapper, manger</li>
  <li><code class="highlighter-rouge">C_4</code> : C’est l’avant dernier bloc du chiffrement.</li>
</ul>

<p><strong>Inconnus</strong></p>

<ul>
  <li><code class="highlighter-rouge">P_5</code> : Le dernier bloc de plaintext de la chaine, ce que nous cherchons à trouver</li>
  <li><code class="highlighter-rouge">P'2</code> : Le bloc de plaintext associé à la concaténation de <code class="highlighter-rouge">X</code> et de <code class="highlighter-rouge">C_5</code></li>
</ul>

<p>Cette équation ne possède plus de cryptographie, seulement du <code class="highlighter-rouge">XOR</code>. Nous avons fait sauter l’aspect cryptographique seulement avec des mathématiques.</p>

<p>Pour pouvoir résoudre cette équation qui pour le moment possède deux inconnues, nous faisons entrer en jeu nos connaissances sur le padding oracle.</p>

<h3 id="invoquons-loracle">Invoquons l’oracle</h3>

<p>Nous avons donc l’égalité suivante grâce à notre raisonnement mathématique</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P'2 = P_5 ⊕ C_4 ⊕ X

# Donc

P_5 = P'2 ⊕ C_4 ⊕ X
</code></pre></div></div>

<p>Cette égalité ne contient que l’opération <code class="highlighter-rouge">XOR</code>. Comme vous le savez, le <code class="highlighter-rouge">XOR</code> est une opération bit à bit, nous pouvons donc découper cette égalité en la calculant octet par octet. Nos blocs faisant 8 octets, nous avons les équations suivantes :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P_5[0] = P'2[0] ⊕ C_4[0] ⊕ X[0]
P_5[1] = P'2[1] ⊕ C_4[1] ⊕ X[1]
P_5[2] = P'2[2] ⊕ C_4[2] ⊕ X[2]
P_5[3] = P'2[3] ⊕ C_4[3] ⊕ X[3]
P_5[4] = P'2[4] ⊕ C_4[4] ⊕ X[4]
P_5[5] = P'2[5] ⊕ C_4[5] ⊕ X[5]
P_5[6] = P'2[6] ⊕ C_4[6] ⊕ X[6]
P_5[7] = P'2[7] ⊕ C_4[7] ⊕ X[7]
</code></pre></div></div>

<p>Nous savons par ailleurs que le déchiffrement d’un texte chiffré doit donner un plaintext avec un padding valide, donc se terminant par <code class="highlighter-rouge">0x01</code> ou <code class="highlighter-rouge">0x02 0x02</code> etc. Comme nous contrôlons tous les octets de <code class="highlighter-rouge">X</code>, nous pouvons bruteforcer le dernier octet jusqu’à ce que l’algorithme de déchiffrement renvoie du texte valide. Dans ce cas-là, ça voudra dire que le padding du texte clair est valide, donc qu’il termine par <code class="highlighter-rouge">0x01</code>.</p>

<p><em>Nous ne prenons pas en compte les faux-positifs dans cet article. En effet, il y a une (faible) chance que le clair se termine par <code class="highlighter-rouge">0x02 0x02</code> ou d’autres padding, mais ces cas sont rares. Je ferai peut-être une mise à jour de l’article pour les prendre en compte plus tard.</em></p>

<p>Une fois qu’on a trouvé l’octet qui donne le padding valide, donc le padding <code class="highlighter-rouge">0x01</code>, en ne prenant l’égalité que sur le dernier octet (donc d’indice 7, puisque nos blocs font 8 octets) …</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P_5[7] = P'2[7] ⊕ C_4[7] ⊕ X[7]
</code></pre></div></div>

<p>… nous pouvons résoudre l’égalité puisque nous connaissons <code class="highlighter-rouge">P'2[7]</code> qui est justement <code class="highlighter-rouge">0x01</code>, mais également <code class="highlighter-rouge">X[7]</code> qui est la valeur du bruteforce et <code class="highlighter-rouge">C_4[7]</code> qui est dans le texte chiffré reçu.</p>

<p>Avec toutes ces informations, nous trouvons donc le dernier octet du dernier bloc de plaintext du texte (qui est du padding, mais c’est un bon début) !</p>

<p>Maintenant, pour retrouver l’octet précédent (donc d’indexe 6), il suffit choisir <code class="highlighter-rouge">X[7]</code> tel que <code class="highlighter-rouge">P'2[7] = 0x2</code> puis de bruteforcer <code class="highlighter-rouge">X[6]</code> pour que le padding soit valide. Quand nous avons une valeur pour <code class="highlighter-rouge">X[6]</code> qui donne un padding valide, cela signifie qu’on a également <code class="highlighter-rouge">P'2[6] = 0x2</code>, et donc on peut résoudre l’égalité</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P_5[6] = P'2[6] ⊕ C_4[6] ⊕ X[6]
</code></pre></div></div>

<p>car nous avons toutes les valeurs en main.</p>

<p>Ce raisonnement est à faire en boucle jusqu’à trouver toutes les valeurs du plaintext du bloc.</p>

<p>Une fois le bloc déchiffré, il suffit de prendre les autres blocs et d’appliquer exactement le même raisonnement. On trouve comme ça les blocs <code class="highlighter-rouge">P_4</code>, <code class="highlighter-rouge">P_3</code> et <code class="highlighter-rouge">P_2</code>.</p>

<p>Un problème se pose cependant pour trouver le bloc <code class="highlighter-rouge">P_1</code>. En effet, pour les cas précédents, nous nous basions sur la connaissance du bloc chiffré qui précédait le bloc en cours de déchiffrement. Cependant, pour le premier bloc, il faut connaitre l’IV utilisé. Dans ce cas, pas de miracle :</p>

<ul>
  <li>Soit vous connaissez l’IV, auquel cas c’est le même raisonnement,</li>
  <li>Soit vous essayez de le deviner en utilisant des combinaisons usuelles, telles qu’un IV nul, ou une suite d’octets consécutifs.</li>
</ul>

<p>Si jamais vous ne pouvez pas le trouver, alors il faudra vous contenter du déchiffrement des blocs 2 à N.</p>

<h2 id="script-python">Script python</h2>

<p>Je vous mets à disposition le script python que j’ai écrit pour du chiffrement AES128 CBC</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#/usr/bin/env python3
</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>
<span class="n">BLOCK_SIZE</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">key</span> <span class="o">=</span> <span class="s">'0123456789abcdef'</span>
<span class="n">IV</span> <span class="o">=</span> <span class="n">BLOCK_SIZE</span> <span class="o">//</span> <span class="mi">8</span> <span class="o">*</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span>
<span class="n">mode</span> <span class="o">=</span> <span class="n">AES</span><span class="o">.</span><span class="n">MODE_CBC</span>

<span class="s">"""
Chiffrement AES 128 CBC
"""</span>
<span class="k">def</span> <span class="nf">encipher</span><span class="p">(</span><span class="n">plain</span><span class="p">):</span>
    <span class="n">encryptor</span> <span class="o">=</span> <span class="n">AES</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">IV</span><span class="o">=</span><span class="n">IV</span><span class="p">)</span>
    <span class="n">padded_plain</span> <span class="o">=</span> <span class="n">set_padding</span><span class="p">(</span><span class="n">plain</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">encryptor</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">padded_plain</span><span class="p">)</span>


<span class="s">"""
Déchiffrement AES 128 CBC
Renvoi False si le padding n'est pas valide
"""</span>
<span class="k">def</span> <span class="nf">decipher</span><span class="p">(</span><span class="n">cipher</span><span class="p">):</span>
    <span class="n">decryptor</span> <span class="o">=</span> <span class="n">AES</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">IV</span><span class="o">=</span><span class="n">IV</span><span class="p">)</span>
    <span class="n">plain_padded</span> <span class="o">=</span> <span class="n">decryptor</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">cipher</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_padding_valid</span><span class="p">(</span><span class="n">plain_padded</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">plain_padded</span>

<span class="s">"""
Ajoute le padding en fonction de la taille d'un bloc
"""</span>
<span class="k">def</span> <span class="nf">set_padding</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size_block</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">size_block</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="n">size_block_byte</span> <span class="o">=</span> <span class="n">size_block</span><span class="o">//</span><span class="mi">8</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="n">size_block_byte</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">%</span> <span class="n">size_block_byte</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span><span class="o">*</span><span class="n">padding</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="s">"""
Supprime le padding
"""</span>
<span class="k">def</span> <span class="nf">del_padding</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>


<span class="s">"""
Vérifie la validité du padding
"""</span>
<span class="k">def</span> <span class="nf">is_padding_valid</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="n">c</span><span class="p">:]</span> <span class="o">==</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">c</span><span class="p">])</span><span class="o">*</span><span class="n">c</span>

<span class="s">"""
Découpe un buffer en blocs en fonction de la taille fournie
"""</span>
<span class="k">def</span> <span class="nf">get_blocks</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size_block</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="mi">128</span><span class="o">//</span><span class="mi">8</span><span class="p">):(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">128</span><span class="o">//</span><span class="mi">8</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="mi">128</span><span class="o">//</span><span class="mi">8</span><span class="p">))]</span>

<span class="s">"""
Déchiffrement du message
Si l'IV est fourni, alors le premier bloc est également déchiffré
"""</span>
<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">cipher</span><span class="p">,</span> <span class="n">IV</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
    <span class="n">cipher_blocks</span> <span class="o">=</span> <span class="n">get_blocks</span><span class="p">(</span><span class="n">cipher</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">b</span><span class="s">""</span>
    <span class="k">if</span> <span class="n">IV</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">cipher_blocks</span> <span class="o">=</span> <span class="p">[</span><span class="nb">bytes</span><span class="p">(</span><span class="n">IV</span><span class="p">,</span> <span class="s">"utf-8"</span><span class="p">)]</span> <span class="o">+</span> <span class="n">cipher_blocks</span>

    <span class="c1"># Les blocs sont déchiffrés un à un
</span>    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cipher_blocks</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">plain</span> <span class="o">=</span> <span class="n">b</span><span class="s">""</span>
        <span class="n">last_cipher_block</span> <span class="o">=</span> <span class="n">cipher_blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">trail</span> <span class="o">=</span> <span class="n">b</span><span class="s">""</span>

        <span class="c1"># Pour chaque bloc, on déchiffre octet par octet
</span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block_size</span><span class="o">//</span><span class="mi">8</span><span class="p">):</span>

            <span class="c1"># Bruteforce pour trouver l'octet qui donne le bon padding
</span>            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
                <span class="n">flip</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
                <span class="n">cipher_block_attack</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="o">-</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span> <span class="o">+</span> <span class="n">flip</span> <span class="o">+</span> <span class="n">trail</span>
                <span class="n">cipher_both_block</span> <span class="o">=</span><span class="n">b</span><span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">cipher_block_attack</span><span class="p">,</span> <span class="n">last_cipher_block</span><span class="p">])</span>

                <span class="c1"># On vérifie la validité du padding suite à un déchiffrement
</span>                <span class="k">if</span> <span class="n">decipher</span><span class="p">(</span><span class="n">cipher_both_block</span><span class="p">):</span>
                    <span class="n">last_plain</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">cipher_blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">15</span><span class="o">-</span><span class="n">k</span><span class="p">]</span> <span class="o">^</span> <span class="n">i</span>
                    <span class="n">plain</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">([</span><span class="n">last_plain</span><span class="p">])</span> <span class="o">+</span> <span class="n">plain</span>
                    <span class="n">trail</span> <span class="o">=</span> <span class="n">b</span><span class="s">""</span>

                    <span class="c1"># Si le bon padding est trouvé, le bloc contrôlé (X dans l'article) est mis à jour
</span>                    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">last_byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">^</span> <span class="n">plain</span><span class="p">[</span><span class="o">-</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">cipher_blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">15</span><span class="o">-</span><span class="n">l</span><span class="p">]</span>
                        <span class="n">trail</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">([</span><span class="n">last_byte</span><span class="p">])</span> <span class="o">+</span> <span class="n">trail</span>
                    <span class="k">break</span>

        <span class="c1"># Suppression du bloc déchiffré
</span>        <span class="n">cipher_blocks</span> <span class="o">=</span> <span class="n">cipher_blocks</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">plain</span> <span class="o">+</span> <span class="n">res</span>
        
    <span class="k">return</span> <span class="n">del_padding</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>


<span class="n">plain</span> <span class="o">=</span> <span class="s">"This is the s3cret key boyz so let's go to work :D"</span>
<span class="n">ciphered</span> <span class="o">=</span> <span class="n">encipher</span><span class="p">(</span><span class="n">plain</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">decrypt</span><span class="p">(</span><span class="n">ciphered</span><span class="p">,</span> <span class="n">IV</span><span class="p">))</span>
</code></pre></div></div>

<p>Lorsqu’on exécute le programme, on obtient bien le résultat escompté</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python padding_oracle.py 
bytearray(b"This is the s3cret key boyz so let\'s go to work :D")
</code></pre></div></div>

<p>Pisse love flex !</p>

  </article>
</div>
<div class="keywords">
    <span class="post-tags"><a href="/archives/#crypto"><i class="fas fa-tags"></i> Crypto</a></span>
  </div>


<br />
<div class="box">
  <div class="dash">
    <div class="picture">
      <img src="/assets/icones/pixis_logo.png" alt="logo" title="logo" />
    </div>
    <div class="box_content">
      <strong>Auteur</strong> : <a href="/contact/" target="_blank">Pixis</a><br />
      Créateur du blog, suivez-moi sur <a href="https://twitter.com/HackAndDo/" target="_blank">twitter</a> ou <a href="https://discord.gg/9At6SUZ" target="blank">discord</a>
    </div>
    
  </div>
</div>


<div class="related">
  <h2>Articles similaires</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/pass-the-hash/">
            Pass the Hash
            <small>18 Dec 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/remote-lsass-dump-passwords/">
            Extraction des secrets de lsass à distance
            <small>28 Nov 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/bloodhound/">
            BloodHound
            <small>30 Jul 2019</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    
    var disqus_config = function () {
        this.page.url = 'http://localhost:4000/padding-oracle/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '0000-0000-0000-0018';
    };
    
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//hackndo.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

        </div>
    </main>
    <script src="/assets/js/jquery-2.1.4.js"></script>
    <script src="/assets/js/jquery.menu-aim.js"></script>
    <script src="/assets/js/anchor.min.js"></script>
    <script src="/assets/js/main.js"></script> <!-- Resource jQuery -->
  </body>
</html>